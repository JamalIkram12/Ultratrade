<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptocurrency Screener</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0f1525;
            color: #e0e0ff;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 4100px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #2a3a5a;
        }
        
        h1 {
            color: #6c8af5;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #8a9bb8;
            font-size: 1.1rem;
        }
        
        .current-timeframe {
            color: #6c8af5;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .last-updated {
            text-align: right;
            margin-bottom: 15px;
            color: #6c8af5;
            font-size: 0.9rem;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .symbol-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .view-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .view-btn.active {
            background-color: #3a4a8a;
            border-color: #6c8af5;
            color: #ffffff;
        }
        
        .view-btn:hover {
            background-color: #2a3a5a;
        }
        
        .timeframe-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 0.9rem;
            color: #8a9bb8;
        }
        
        .control-group select {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #e0e0ff;
            padding: 6px 10px;
            border-radius: 4px;
            min-width: 100px;
        }
        
        .refresh-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .refresh-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .refresh-btn:hover {
            background-color: #2a3a5a;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4caf50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Watchlist Dropdown Styles */
        .watchlist-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .watchlist-dropdown-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .watchlist-dropdown-btn:hover {
            background-color: #2a3a5a;
        }
        
        .watchlist-dropdown-content {
            display: none;
            position: absolute;
            background-color: #1a2238;
            min-width: 200px;
            border: 1px solid #2a3a5a;
            border-radius: 6px;
            z-index: 1000;
            top: 100%;
            left: 0;
            margin-top: 5px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }
        
        .watchlist-dropdown-content.show {
            display: block;
        }
        
        .watchlist-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #2a3a5a;
            transition: all 0.3s;
        }
        
        .watchlist-item:last-child {
            border-bottom: none;
        }
        
        .watchlist-item:hover {
            background-color: #2a3a5a;
        }
        
        .watchlist-item.active {
            background-color: #3a4a8a;
            color: #ffffff;
        }
        
        .watchlist-item-count {
            float: right;
            background-color: #6c8af5;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.8rem;
        }
        
        .watchlist-manage-btn {
            padding: 10px 15px;
            background-color: #2a3a5a;
            border-top: 1px solid #2a3a5a;
            cursor: pointer;
            text-align: center;
            font-size: 0.9rem;
            color: #6c8af5;
        }
        
        .watchlist-manage-btn:hover {
            background-color: #3a4a8a;
        }
        
        /* Filter Panel Styles */
        .filter-panel-container {
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            background-color: #121a2d;
            overflow: hidden;
        }
        
        .filter-panel-header {
            background-color: #1a2238;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #2a3a5a;
        }
        
        .filter-panel-header:hover {
            background-color: #2a3a5a;
        }
        
        .filter-panel-header h3 {
            color: #6c8af5;
            font-size: 1.1rem;
        }
        
        .filter-panel-header i {
            transition: transform 0.3s ease;
        }
        
        .filter-panel-header i.rotated {
            transform: rotate(180deg);
        }
        
        .filter-panel {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .filter-panel.collapsed {
            display: none;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .filter-group label {
            font-size: 0.9rem;
            color: #8a9bb8;
            font-weight: 500;
        }
        
        .filter-select {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #e0e0ff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            width: 100%;
            cursor: pointer;
        }
        
        .filter-select:hover {
            border-color: #3a4a8a;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: #6c8af5;
        }
        
        .filter-actions {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            padding-top: 10px;
            border-top: 1px solid #2a3a5a;
        }
        
        .filter-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .filter-btn:hover {
            background-color: #2a3a5a;
        }
        
        .filter-btn.primary {
            background-color: #3a4a8a;
            border-color: #6c8af5;
            color: #ffffff;
        }
        
        .filter-btn.primary:hover {
            background-color: #4a5a9a;
        }
        
        .active-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .active-filter-tag {
            background-color: #2a3a5a;
            color: #a0b0f0;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .active-filter-tag i {
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .active-filter-tag i:hover {
            color: #f44336;
        }
        
        .clear-filters-btn {
            background-color: transparent;
            border: 1px solid #2a3a5a;
            color: #8a9bb8;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .clear-filters-btn:hover {
            background-color: #2a3a5a;
            color: #e0e0ff;
        }
        
        .filter-results {
            color: #8a9bb8;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        /* UPDATED TABLE CONTAINER FOR STICKY HEADER AND COLUMN */
        .table-container {
            overflow: auto;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            background-color: #121a2d;
            max-height: 70vh;
            position: relative;
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            min-width: 4000px; /* Adjusted width for removed column */
            position: relative;
        }
        
        thead {
            background-color: #1a2238;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        th {
            padding: 18px 15px;
            text-align: left;
            color: #6c8af5;
            font-weight: 600;
            border-bottom: 1px solid #2a3a5a;
            white-space: nowrap;
            position: relative;
        }
        
        /* First header cell (cryptocurrency pair header) should be sticky left */
        th:first-child {
            position: sticky;
            left: 0;
            z-index: 101;
            background-color: #1a2238;
            border-right: 1px solid #2a3a5a;
        }
        
        th i {
            margin-right: 8px;
        }
        
        td {
            padding: 16px 15px;
            border-bottom: 1px solid #2a3a5a;
            white-space: nowrap;
        }
        
        /* First data cell (cryptocurrency pair) should be sticky left */
        td:first-child {
            position: sticky;
            left: 0;
            z-index: 99;
            background-color: #121a2d;
            border-right: 1px solid #2a3a5a;
        }
        
        /* Ensure the sticky first column cells have proper background when row is hovered */
        tbody tr:hover td:first-child {
            background-color: #1a2238;
        }
        
        tbody tr:last-child td {
            border-bottom: none;
        }
        
        tbody tr:hover {
            background-color: #1a2238;
        }
        
        .crypto-name {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .watchlist-star {
            color: #8a9bb8;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
            min-width: 24px;
            display: inline-block;
        }
        
        .watchlist-star:hover {
            color: #ffc107;
            transform: scale(1.2);
        }
        
        .watchlist-star.active {
            color: #ffc107;
        }
        
        .watchlist-star.active:hover {
            color: #ff9800;
        }
        
        .crypto-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: #2a3a5a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .btc { background-color: #f7931a; color: #000; }
        .eth { background-color: #627eea; color: #fff; }
        .ada { background-color: #0033ad; color: #fff; }
        .xrp { background-color: #23292f; color: #fff; }
        .avax { background-color: #e84142; color: #fff; }
        
        .crypto-link {
            color: #e0e0ff;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .crypto-link:hover {
            color: #6c8af5;
            background-color: rgba(108, 138, 245, 0.1);
            text-decoration: underline;
        }
        
        .crypto-link i {
            margin-right: 5px;
            font-size: 0.9rem;
            color: #6c8af5;
        }
        
        .price {
            font-weight: 700;
            font-size: 1.2rem;
            transition: color 0.5s ease;
        }
        
        .price.up {
            color: #4caf50;
        }
        
        .price.down {
            color: #f44336;
        }
        
        .price.neutral {
            color: #e0e0ff;
        }
        
        .price-change {
            font-size: 0.9rem;
            margin-top: 4px;
        }
        
        .macd-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .macd-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .macd-positive {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        
        .macd-negative {
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .macd-neutral {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .macd-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .crossover-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .crossover-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .bullish-crossover {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .bearish-crossover {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .no-crossover {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .volume-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .volume-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .volume-spike {
            background-color: rgba(155, 81, 224, 0.3);
            color: #9b51e0;
            border: 1px solid rgba(155, 81, 224, 0.5);
        }
        
        .volume-normal {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .volume-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .atr-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .atr-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .atr-high {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .atr-moderate {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .atr-good {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .atr-low {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .atr-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .obv-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .obv-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .obv-rising {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .obv-falling {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .obv-neutral {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .obv-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .ichimoku-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ichimoku-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .ichimoku-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .ichimoku-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .ichimoku-inside {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .ichimoku-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .ema-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ema-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .ema-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .ema-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .ema-cross {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .ema-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .correlation-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .correlation-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .correlation-low {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .correlation-medium {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .correlation-high {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .correlation-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .support-levels-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .support-levels-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .support-levels-active {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .support-levels-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .support-levels-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .flipped-support-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .flipped-support-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .flipped-support-active {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .flipped-support-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .flipped-support-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW LIQUIDITY GRAB SUPPORT INDICATOR STYLES */
        .liquidity-grab-support-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .liquidity-grab-support-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .liquidity-grab-support-yes {
            background-color: rgba(0, 150, 255, 0.3);
            color: #0096ff;
            border: 1px solid rgba(0, 150, 255, 0.5);
        }
        
        .liquidity-grab-support-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .liquidity-grab-support-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .resistance-levels-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .resistance-levels-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .resistance-levels-active {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .resistance-levels-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .resistance-levels-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .flipped-resistance-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .flipped-resistance-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .flipped-resistance-active {
            background-color: rgba(155, 81, 224, 0.3);
            color: #9b51e0;
            border: 1px solid rgba(155, 81, 224, 0.5);
        }
        
        .flipped-resistance-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .flipped-resistance-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW LIQUIDITY GRAB RESISTANCE INDICATOR STYLES */
        .liquidity-grab-resistance-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .liquidity-grab-resistance-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .liquidity-grab-resistance-yes {
            background-color: rgba(255, 87, 34, 0.3);
            color: #ff5722;
            border: 1px solid rgba(255, 87, 34, 0.5);
        }
        
        .liquidity-grab-resistance-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .liquidity-grab-resistance-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .cpr-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .cpr-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .cpr-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .cpr-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .cpr-inside {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .cpr-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .cpr-level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 4px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .cpr-tc {
            border-left-color: #9b51e0;
        }
        
        .cpr-cp {
            border-left-color: #6c8af5;
        }
        
        .cpr-bc {
            border-left-color: #4caf50;
        }
        
        .support-convergence-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .support-convergence-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .support-convergence-yes {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .support-convergence-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .support-convergence-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW RESISTANCE CONVERGENCE INDICATOR STYLES */
        .resistance-convergence-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .resistance-convergence-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .resistance-convergence-yes {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .resistance-convergence-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .resistance-convergence-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .convergence-price {
            font-weight: 600;
            color: #ffc107;
            font-family: 'Courier New', monospace;
        }
        
        /* VWAP Indicator Styles */
        .vwap-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .vwap-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .vwap-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .vwap-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .vwap-near {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .vwap-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .vwap-band-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 4px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .vwap-upper {
            border-left-color: #f44336;
        }
        
        .vwap-line {
            border-left-color: #6c8af5;
        }
        
        .vwap-lower {
            border-left-color: #4caf50;
        }
        
        /* UPDATED INDICATOR SUMMARY STYLES - THREE COLUMNS */
        .indicator-summary-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 180px;
            max-width: 200px;
        }
        
        .indicator-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 6px;
            font-size: 0.85rem;
            border-left: 4px solid transparent;
        }
        
        .indicator-summary-label {
            color: #8a9bb8;
            font-weight: 500;
            min-width: 100px;
        }
        
        .indicator-summary-value {
            font-weight: 600;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        /* Color coding for indicator values */
        .summary-positive {
            color: #4caf50 !important; /* Green for bullish/positive */
        }
        
        .summary-negative {
            color: #f44336 !important; /* Red for bearish/negative */
        }
        
        .summary-neutral {
            color: #ffc107 !important; /* Yellow for neutral */
        }
        
        .summary-info {
            color: #6c8af5 !important; /* Blue for informational */
        }
        
        .summary-highlight {
            background: rgba(108, 138, 245, 0.1);
            border-left-color: #6c8af5;
        }
        
        /* Border colors for different indicator types */
        .summary-macd { border-left-color: #4caf50; }
        .summary-crossover { border-left-color: #9b51e0; }
        .summary-volume { border-left-color: #ff9800; }
        .summary-atr { border-left-color: #f44336; }
        .summary-obv { border-left-color: #2196f3; }
        .summary-ichimoku { border-left-color: #00bcd4; }
        .summary-ema { border-left-color: #ffc107; }
        .summary-support { border-left-color: #4caf50; }
        .summary-flipped { border-left-color: #ffc107; }
        .summary-resistance { border-left-color: #f44336; }
        .summary-flipped-resistance { border-left-color: #9b51e0; }
        .summary-cpr { border-left-color: #9b51e0; }
        .summary-vwap { border-left-color: #9c27b0; }
        .summary-correlation { border-left-color: #3f51b5; }
        .summary-convergence { border-left-color: #4caf50; }
        .summary-resistance-convergence { border-left-color: #f44336; }
        .summary-liquidity-support { border-left-color: #0096ff; }
        .summary-liquidity-resistance { border-left-color: #ff5722; }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #8a9bb8;
        }
        
        .loading-spinner {
            border: 3px solid #2a3a5a;
            border-top: 3px solid #6c8af5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            color: #f44336;
            background-color: rgba(244, 67, 54, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
        }
        
        .error.show {
            display: block;
        }
        
        .watchlist-count {
            display: inline-block;
            background-color: #6c8af5;
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .app-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 21, 37, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .app-modal-content {
            background-color: #1a2238;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        
        .app-modal h3 {
            color: #6c8af5;
            margin-bottom: 15px;
        }
        
        .app-modal p {
            margin-bottom: 20px;
            color: #8a9bb8;
        }
        
        .app-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .app-modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .app-modal-btn.primary {
            background-color: #6c8af5;
            color: white;
            border: none;
        }
        
        .app-modal-btn.secondary {
            background-color: transparent;
            color: #8a9bb8;
            border: 1px solid #2a3a5a;
        }
        
        .app-modal-btn:hover {
            opacity: 0.9;
        }
        
        /* Watchlist Selection Modal Styles */
        .watchlist-selection-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 21, 37, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .watchlist-selection-content {
            background-color: #1a2238;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            max-width: 400px;
            width: 90%;
            text-align: left;
        }
        
        .watchlist-selection-content h3 {
            color: #6c8af5;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .watchlist-selection-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin-bottom: 10px;
            background-color: #121a2d;
            border-radius: 6px;
            border: 1px solid #2a3a5a;
            transition: all 0.3s;
        }
        
        .watchlist-selection-item:hover {
            background-color: #1a2238;
            border-color: #3a4a8a;
        }
        
        .watchlist-selection-label {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .watchlist-selection-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .watchlist-selection-name {
            font-weight: 500;
            color: #e0e0ff;
        }
        
        .watchlist-selection-count {
            background-color: #3a4a8a;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.8rem;
        }
        
        .watchlist-selection-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        /* Watchlist Management Modal Styles */
        .watchlist-management-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 21, 37, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .watchlist-management-content {
            background-color: #1a2238;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            max-width: 500px;
            width: 90%;
            text-align: left;
        }
        
        .watchlist-management-content h3 {
            color: #6c8af5;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .watchlist-management-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            margin-bottom: 10px;
            background-color: #121a2d;
            border-radius: 6px;
            border: 1px solid #2a3a5a;
        }
        
        .watchlist-management-input {
            flex: 1;
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #e0e0ff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .watchlist-management-input:focus {
            outline: none;
            border-color: #6c8af5;
        }
        
        .watchlist-management-count {
            background-color: #3a4a8a;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.8rem;
            min-width: 60px;
            text-align: center;
        }
        
        .watchlist-management-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #2a3a5a;
            color: #8a9bb8;
            font-size: 0.9rem;
        }
        
        .progress-bar-container {
            width: 100%;
            background-color: #2a3a5a;
            border-radius: 10px;
            overflow: hidden;
            height: 8px;
            margin-top: 5px;
        }
        
        .progress-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .progress-bar.low {
            background-color: #4caf50;
        }
        
        .progress-bar.medium {
            background-color: #ffc107;
        }
        
        .progress-bar.high {
            background-color: #f44336;
        }
        
        .level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 6px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }
        
        .support-level {
            border-left-color: #4caf50;
        }
        
        .flipped-level {
            border-left-color: #ffc107;
        }
        
        .resistance-level {
            border-left-color: #f44336;
        }
        
        .flipped-resistance-level {
            border-left-color: #9b51e0;
        }
        
        .level-price {
            font-weight: 600;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }
        
        .level-percent {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .percent-positive {
            background: rgba(76, 175, 129, 0.2);
            color: #4caf50;
        }
        
        .percent-negative {
            background: rgba(239, 68, 68, 0.2);
            color: #f44336;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .timeframe-controls {
                justify-content: center;
            }
            
            .refresh-controls {
                justify-content: center;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            th, td {
                padding: 12px 10px;
            }
            
            .app-modal-buttons {
                flex-direction: column;
            }
            
            .indicator-summary-container {
                min-width: 150px;
            }
            
            .indicator-summary-label {
                min-width: 80px;
                font-size: 0.8rem;
            }
            
            .indicator-summary-value {
                font-size: 0.8rem;
            }
            
            .filter-panel {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 10px;
                padding: 15px;
            }
            
            .filter-actions {
                flex-direction: column;
            }
            
            .watchlist-dropdown-content {
                min-width: 180px;
            }
            
            /* Adjust sticky positioning for mobile */
            th:first-child, td:first-child {
                position: sticky;
                left: 0;
                z-index: 99;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-chart-line"></i> Cryptocurrency Screener</h1>
            <p class="subtitle">Real-time price data with comprehensive technical analysis for major cryptocurrencies <span class="current-timeframe">(1 Hour Timeframe)</span></p>
        </header>
        
        <div class="last-updated">
            Last updated: <span id="last-updated-time">--:--:--</span>
            <div id="watchlist-count-display" style="display: inline-block; margin-left: 15px; color: #ffc107;">
                <i class="fas fa-star"></i> <span id="watchlist-count">0</span> in <span id="current-watchlist-name">All Coins</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="symbol-selector">
                <button class="view-btn active" id="view-all-btn">
                    <i class="fas fa-coins"></i> All Coins
                </button>
                <div class="watchlist-dropdown">
                    <button class="view-btn watchlist-dropdown-btn" id="watchlist-dropdown-btn">
                        <i class="fas fa-star"></i> Watchlists <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="watchlist-dropdown-content" id="watchlist-dropdown-content">
                        <div class="watchlist-item" data-watchlist="all">
                            <span>All Coins</span>
                            <span class="watchlist-item-count" id="watchlist-all-count">4</span>
                        </div>
                        <div class="watchlist-item active" data-watchlist="list1">
                            <span>Watchlist 1</span>
                            <span class="watchlist-item-count" id="watchlist-list1-count">0</span>
                        </div>
                        <div class="watchlist-item" data-watchlist="list2">
                            <span>Watchlist 2</span>
                            <span class="watchlist-item-count" id="watchlist-list2-count">0</span>
                        </div>
                        <div class="watchlist-item" data-watchlist="list3">
                            <span>Watchlist 3</span>
                            <span class="watchlist-item-count" id="watchlist-list3-count">0</span>
                        </div>
                        <div class="watchlist-item" data-watchlist="list4">
                            <span>Watchlist 4</span>
                            <span class="watchlist-item-count" id="watchlist-list4-count">0</span>
                        </div>
                        <div class="watchlist-item" data-watchlist="list5">
                            <span>Watchlist 5</span>
                            <span class="watchlist-item-count" id="watchlist-list5-count">0</span>
                        </div>
                        <div class="watchlist-manage-btn" id="manage-watchlists-btn">
                            <i class="fas fa-cog"></i> Manage Watchlists
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="timeframe-controls">
                <div class="control-group">
                    <label for="timeframe-select"><i class="fas fa-clock"></i> Timeframe:</label>
                    <select id="timeframe-select">
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hour</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="ema-period"><i class="fas fa-wave-square"></i> EMA Period:</label>
                    <select id="ema-period">
                        <option value="9">9 Period</option>
                        <option value="20" selected>20 Period</option>
                        <option value="50">50 Period</option>
                        <option value="100">100 Period</option>
                        <option value="200">200 Period</option>
                    </select>
                </div>
            </div>
            
            <div class="refresh-controls">
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Live Data</span>
                </div>
                <button class="refresh-btn" id="refresh-data">
                    <i class="fas fa-sync-alt"></i> Refresh Data
                </button>
            </div>
        </div>
        
        <!-- Filter Panel -->
        <div class="filter-panel-container">
            <div class="filter-panel-header" id="filter-panel-toggle">
                <h3><i class="fas fa-filter"></i> Filter Options</h3>
                <i class="fas fa-chevron-down" id="filter-panel-icon"></i>
            </div>
            <div class="filter-panel" id="filter-panel">
                <div class="filter-group">
                    <label for="filter-macd">MACD</label>
                    <select id="filter-macd" class="filter-select">
                        <option value="all">All</option>
                        <option value="Positive">Positive</option>
                        <option value="Negative">Negative</option>
                        <option value="Neutral">Neutral</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-crossover">MACD Crossover</label>
                    <select id="filter-crossover" class="filter-select">
                        <option value="all">All</option>
                        <option value="Bullish Crossover">Bullish Crossover</option>
                        <option value="Bearish Crossover">Bearish Crossover</option>
                        <option value="None">No Crossover</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-volume">Volume Spike</label>
                    <select id="filter-volume" class="filter-select">
                        <option value="all">All</option>
                        <option value="Spike">Spike</option>
                        <option value="Normal">Normal</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-atr">Volatility ATR</label>
                    <select id="filter-atr" class="filter-select">
                        <option value="all">All</option>
                        <option value="High">High</option>
                        <option value="Good">Good</option>
                        <option value="Moderate">Moderate</option>
                        <option value="Low">Low</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-obv">OBV</label>
                    <select id="filter-obv" class="filter-select">
                        <option value="all">All</option>
                        <option value="Rising Volume">Rising Volume</option>
                        <option value="Declining Volume">Declining Volume</option>
                        <option value="None">None</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-ichimoku">Ichimoku Cloud</label>
                    <select id="filter-ichimoku" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above Cloud">Above Cloud</option>
                        <option value="Below Cloud">Below Cloud</option>
                        <option value="Inside Cloud">Inside Cloud</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-ema">EMA</label>
                    <select id="filter-ema" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above EMA">Above EMA</option>
                        <option value="Below EMA">Below EMA</option>
                        <option value="Near EMA">Near EMA</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-correlation">Correlation with BTC</label>
                    <select id="filter-correlation" class="filter-select">
                        <option value="all">All</option>
                        <option value="High">High</option>
                        <option value="Medium">Medium</option>
                        <option value="Low">Low</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-support">Support Level</label>
                    <select id="filter-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Support">No Support</option>
                        <option value="Has Support">Has Support</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-flipped-support">Flipped Support</label>
                    <select id="filter-flipped-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Flipped Support">No Flipped Support</option>
                        <option value="Has Flipped Support">Has Flipped Support</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-resistance">Resistance Level</label>
                    <select id="filter-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Resistance">No Resistance</option>
                        <option value="Has Resistance">Has Resistance</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-flipped-resistance">Flipped Resistance</label>
                    <select id="filter-flipped-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Flipped Resistance">No Flipped Resistance</option>
                        <option value="Has Flipped Resistance">Has Flipped Resistance</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-liquidity-support">Liquidity Grab Support</label>
                    <select id="filter-liquidity-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="Yes">Yes</option>
                        <option value="No">No</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-liquidity-resistance">Liquidity Grab Resistance</label>
                    <select id="filter-liquidity-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="Yes">Yes</option>
                        <option value="No">No</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-cpr">Daily CPR</label>
                    <select id="filter-cpr" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above CPR">Above CPR</option>
                        <option value="Below CPR">Below CPR</option>
                        <option value="Inside CPR">Inside CPR</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-convergence">Support Convergence</label>
                    <select id="filter-convergence" class="filter-select">
                        <option value="all">All</option>
                        <option value="Solid Support">Solid Support</option>
                        <option value="No Convergence">No Convergence</option>
                    </select>
                </div>
                
                <!-- NEW RESISTANCE CONVERGENCE FILTER -->
                <div class="filter-group">
                    <label for="filter-resistance-convergence">Resistance Convergence</label>
                    <select id="filter-resistance-convergence" class="filter-select">
                        <option value="all">All</option>
                        <option value="Solid Resistance">Solid Resistance</option>
                        <option value="No Convergence">No Convergence</option>
                    </select>
                </div>
                
                <div class="filter-actions">
                    <button class="filter-btn primary" id="apply-filters">
                        <i class="fas fa-check"></i> Apply Filters
                    </button>
                    <button class="filter-btn" id="reset-filters">
                        <i class="fas fa-undo"></i> Reset All
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Active Filters Display -->
        <div class="active-filters" id="active-filters-container" style="display: none;">
            <div id="active-filters-list"></div>
            <button class="clear-filters-btn" id="clear-filters">
                <i class="fas fa-times"></i> Clear All Filters
            </button>
            <div class="filter-results" id="filter-results"></div>
        </div>
        
        <div class="error" id="error-message"></div>
        
        <!-- UPDATED TABLE CONTAINER WITH STICKY HEADER AND FIRST COLUMN -->
        <div class="table-container">
            <table id="crypto-table">
                <thead>
                    <tr>
                        <th><i class="fas fa-coins"></i> Cryptocurrency Pair</th>
                        <th><i class="fas fa-dollar-sign"></i> Current Price</th>
                        <th><i class="fas fa-chart-bar"></i> MACD (1h)</th>
                        <th><i class="fas fa-exchange-alt"></i> MACD Crossover</th>
                        <th><i class="fas fa-chart-area"></i> Volume Spike</th>
                        <th><i class="fas fa-chart-line"></i> Volatility ATR (4h)</th>
                        <th><i class="fas fa-balance-scale"></i> OBV (1h)</th>
                        <th><i class="fas fa-cloud"></i> Ichimoku Cloud</th>
                        <th><i class="fas fa-chart-line"></i> EMA Position</th>
                        <th><i class="fas fa-link"></i> Correlation with BTC</th>
                        <th><i class="fas fa-shield-alt"></i> Support Levels (LL/HL)</th>
                        <th><i class="fas fa-exchange-alt"></i> Flipped Support (Breached HH/LH)</th>
                        <th><i class="fas fa-hand-point-down"></i> Liquidity Grab (Support)</th>
                        <th><i class="fas fa-ban"></i> Resistance Levels (HH/LH)</th>
                        <th><i class="fas fa-exchange-alt"></i> Flipped Resistance (Breached LL/HL)</th>
                        <th><i class="fas fa-hand-point-up"></i> Liquidity Grab (Resistance)</th>
                        <th><i class="fas fa-balance-scale"></i> Daily CPR (TC/CP/BC)</th>
                        <th><i class="fas fa-handshake"></i> Support Convergence</th>
                        <!-- NEW RESISTANCE CONVERGENCE COLUMN -->
                        <th><i class="fas fa-handshake"></i> Resistance Convergence</th>
                        <th><i class="fas fa-weight-hanging"></i> VWAP (Session)</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 1</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 2</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 3</th>
                        <!-- NEW BINANCE COLUMN -->
                        <th><i class="fas fa-exchange-alt"></i> Binance Trade</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <tr class="loading">
                        <td colspan="24"> <!-- Updated colspan from 25 to 24 -->
                            <div class="loading-spinner"></div>
                            <div>Loading cryptocurrency data from Binance...</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- TradingView Selection Modal -->
        <div class="app-modal" id="tradingview-modal">
            <div class="app-modal-content">
                <h3><i class="fas fa-external-link-alt"></i> Open in TradingView</h3>
                <p>Would you like to open this chart in the TradingView mobile app or continue in browser?</p>
                <div class="app-modal-buttons">
                    <button class="app-modal-btn primary" id="tradingview-open-app-btn">
                        <i class="fas fa-mobile-alt"></i> Open in App
                    </button>
                    <button class="app-modal-btn secondary" id="tradingview-open-web-btn">
                        <i class="fas fa-globe"></i> Open in Browser
                    </button>
                    <button class="app-modal-btn secondary" id="tradingview-cancel-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Binance Selection Modal -->
        <div class="app-modal" id="binance-modal">
            <div class="app-modal-content">
                <h3><i class="fas fa-exchange-alt"></i> Open in Binance</h3>
                <p>Would you like to open this pair in the Binance mobile app for spot trading or continue on the Binance website?</p>
                <div class="app-modal-buttons">
                    <button class="app-modal-btn primary" id="binance-open-app-btn">
                        <i class="fas fa-mobile-alt"></i> Open in App
                    </button>
                    <button class="app-modal-btn secondary" id="binance-open-web-btn">
                        <i class="fas fa-globe"></i> Open in Browser
                    </button>
                    <button class="app-modal-btn secondary" id="binance-cancel-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Watchlist Selection Modal -->
        <div class="watchlist-selection-modal" id="watchlist-selection-modal">
            <div class="watchlist-selection-content">
                <h3><i class="fas fa-star"></i> Add to Watchlists</h3>
                <p id="watchlist-selection-symbol" style="margin-bottom: 20px; text-align: center; color: #ffc107;"></p>
                <div id="watchlist-selection-list">
                    <!-- Watchlist selection items will be added here dynamically -->
                </div>
                <div class="watchlist-selection-actions">
                    <button class="app-modal-btn primary" id="watchlist-selection-save-btn">
                        <i class="fas fa-check"></i> Save Selection
                    </button>
                    <button class="app-modal-btn secondary" id="watchlist-selection-cancel-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Watchlist Management Modal -->
        <div class="watchlist-management-modal" id="watchlist-management-modal">
            <div class="watchlist-management-content">
                <h3><i class="fas fa-cog"></i> Manage Watchlists</h3>
                <p style="margin-bottom: 20px; text-align: center; color: #8a9bb8;">Rename your watchlists below:</p>
                <div id="watchlist-management-list">
                    <!-- Watchlist management items will be added here dynamically -->
                </div>
                <div class="watchlist-management-actions">
                    <button class="app-modal-btn primary" id="watchlist-management-save-btn">
                        <i class="fas fa-check"></i> Save Changes
                    </button>
                    <button class="app-modal-btn secondary" id="watchlist-management-cancel-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Data provided by Binance Public API | Prices update every second via WebSocket | Volatility (ATR) based on 4-hour timeframe in 1-hour mode, 12-hour in 4-hour mode | All other indicators based on selected timeframe mode | Correlation calculated over last 24 hours | CPR calculated from daily timeframe using PREVIOUS DAY'S data | VWAP calculated on daily session with (H+L+C)/3 source and 1 standard deviation bands</p>
            <p>This is a demonstration tool. Cryptocurrency investments are subject to market risk.</p>
        </footer>
    </div>

    <script>
        // Configuration
        const SYMBOLS = ['BTCUSDT', 'ETHUSDT', '0GUSDT', '1000CATUSDT', '1000CHEEMSUSDT', '1000SATSUSDT', '1INCHUSDT', '1MBABYDOGEUSDT', '2ZUSDT', 'A2ZUSDT', 'AAVEUSDT', 'ACAUSDT', 'ACCMUSDT', 'ACXUSDT', 'ACTUSDT', 'ADAUSDT', 'ADXUSDT', 'AEURUSDT', 'AEVOUSDT', 'AIGLDTUSDT', 'AIOUSDT', 'AIXBTUSDT', 'AGLDUSDT', 'ALCXUSDT', 'ALGOUSDT', 'ALICEUSDT', 'ALLOUSDT', 'ALPINEUSDT', 'ALTUSDT', 'AMPUSDT', 'ANIMEUSDT', 'ANKRUSDT', 'APEUSDT', 'API3USDT', 'APTUSDT', 'ARBUSDT', 'ARDRUSDT', 'AREUSDT', 'ARKMUSDT', 'ARKUSDT', 'ARPAUSDT', 'ARUSDT', 'ASRUSDT', 'ASTERUSDT', 'ATAUSDT', 'ATLASUSDT', 'ATMOSDT', 'ATOMUSDT', 'AUDIOUSDT', 'AUSDT', 'AVAUSDT', 'AVANTUSDT', 'AVAXUSDT', 'AXLUSDT', 'AXSUSDT', 'AZEURUSDT', 'BABYUSDT', 'BANANAUSDT', 'BANANAS31USDT', 'BANDUSDT', 'BARUSDT', 'BATUSDT', 'BBUSDT', 'BCHUSDT', 'BEAMXUSDT', 'BELUSDT', 'BERAUSDT', 'BFUSDUSDT', 'BICOUSDT', 'BIFIUSDT', 'BIGTIMEUSDT', 'BIOUSDT', 'BNTUSDT', 'BNBOSDT', 'BOMEUSDT', 'BONKUSDT', 'BROCCOLI714USDT', 'BTCUSDT', 'BTTUSDT', 'CAKEUSDT', 'CATIUSDT', 'CETUSUSDT', 'CFLXUSDT', 'CFXUSDT', 'CGBIOUSDT', 'CGPTUSDT', 'CELRUSDT', 'CELOUSDT', 'CHESSUSDT', 'CHZUSDT', 'CITYUSDT', 'CIVIOUSDT', 'CKBUSDT', 'CLARUSDT', 'CLUXUSDT', 'CLVRUSDT', 'COMPUSDT', 'COOKIEUSDT', 'COTIUSDT', 'COVLUSDT', 'COVUSDT', 'COWUSDT', 'CPOUSDT', 'CRVUSDT', 'CSPRUSDT', 'CTKUSDT', 'CTSIUSDT', 'CVCUSDT', 'CVXUSDT', 'CXCUSDT', 'CYBERUSDT', 'DASHUSDT', 'DATAUSDT', 'DEFIUSDT', 'DEGOUSDT', 'DENTUSDT', 'DFUSDT', 'DGBUSDT', 'DGLDUSDT', 'DIAUSDT', 'DNTUSDT', 'DOGEUSDT', 'DOGEOSDT', 'DOGOUSDT', 'DODOUSDT', 'DOLUSDT', 'DOLXUSDT', 'DREAMUSDT', 'DUSDT', 'DUSUSDT', 'DYDXUSDT', 'DYMUSDT', 'EDENUSDT', 'EDUSDT', 'EGLDUSDT', 'EIGENUSDT', 'ENJUSDT', 'ENSOUSDT', 'ENSUSDT', 'EPICTUSDT', 'EPOUSDT', 'ERAUSDT', 'ETCUSDT', 'ETHFIUSDT', 'EURUSDT', 'EURIUSDT', 'EULUSDT', 'FARMUSDT', 'FETUSDT', 'FFUSDT', 'FIDAUSDT', 'FILUSDT', 'FIOUSDT', 'FISUSDT', 'FLMUSDT', 'FLOKIUSDT', 'FLOWUSDT', 'FORTHUSDT', 'FTMUSDT', 'FTTUSDT', 'FUNUSDT', 'GALUSDT', 'GALAUSDT', 'GASUSDT', 'GGMUSDT', 'GFUSDT', 'GHSTUSDT', 'GIGGLEUSDT', 'GLMRUSDT', 'GLMUSDT', 'GMTUSDT', 'GMMUSDT', 'GMXUSDT', 'GNOUSDT', 'GNOSUSDT', 'GNSUSDT', 'GODUSDT', 'GRATUSDT', 'GRTUSDT', 'GTCUSDT', 'GUNUSDT', 'HADOUSDT', 'HEDALUSDT', 'HEMIUSDT', 'HFTUSDT', 'HIGHUSDT', 'HIVEUSDT', 'HMSTRUSDT', 'HOLOUSDT', 'HOMEUSDT', 'HOTUSDT', 'HUMAUSDT', 'HYPERUSDT', 'ICOUSDT', 'ICPUSDT', 'ICXUSDT', 'IDEXUSDT', 'IDUSDT', 'ILVUSDT', 'IMXUSDT', 'INJUSDT', 'INITUSDT', 'IOTAUSDT', 'IOTXUSDT', 'IOUSDT', 'IQUSDT', 'JASMYUSDT', 'JSTUSDT', 'JTOUSDT', 'JUPUSDT', 'KAIAUSDT', 'KAIUSDT', 'KAVAUSDT', 'KERNALUSDT', 'KITESUSDT', 'KLAYUSDT', 'KMNOUSDT', 'KNCUSDT', 'KSMUSDT', 'LAYERUSDT', 'LAUSDT', 'LDOUSDT', 'LINKUSDT', 'LISTAUSDT', 'LITUSDT', 'LIVIOUSDT', 'LPCUSDT', 'LPTUSDT', 'LQTYUSDT', 'LRCUSDT', 'LSKUSDT', 'LTCUSDT', 'MAGICUSDT', 'MANAUSDT', 'MANTAUSDT', 'MASKUSDT', 'MATICUSDT', 'MBLUSDT', 'MBOXUSDT', 'MDTUSDT', 'MELOSUSDT', 'METAUSDT', 'METISUSDT', 'MEEUSDT', 'MEUSDT', 'MFTUSDT', 'MINAUSDT', 'MIRRAUSDT', 'MITOUSDT', 'MKRUSDT', 'MLNUSDT', 'MMSUSDT', 'MMTUSDT', 'MOVEUSDT', 'MOVRUSDT', 'MPLUSDT', 'MROUSDT', 'MTLUSDT', 'MUBARAKUSDT', 'MYROUSDT', 'NANOUSDT', 'NEARUSDT', 'NEIROUSDT', 'NEOUSDT', 'NEXOUSDT', 'NFPUSDT', 'NILUSDT', 'NKNUSDT', 'NMRUSDT', 'NOMUSDT', 'NXPCUSDT', 'OAXUSDT', 'OGNUSDT', 'OGUSDT', 'OMUSDT', 'ONDOUSDT', 'ONEUSDT', 'ONGUSDT', 'ONTUSDT', 'ONYXUSDT', 'OPENUSDT', 'OPUSDT', 'ORBSUSDT', 'ORCAUSDT', 'ORDIUSDT', 'OSMOUSDT', 'OXTUSDT', 'PAXGUSDT', 'PEOPLEUSDT', 'PEPEUSDT', 'PENDLEUSDT', 'PHAUSDT', 'PHABUSDT', 'PHBUSDT', 'PIXELUSDT', 'PIVXUSDT', 'PLUMEUSDT', 'POLUSDT', 'POLYXUSDT', 'PONDUSDT', 'PORTALUSDT', 'PORTOUSDT', 'POWRUSDT', 'PROMUSDT', 'PROVEUSDT', 'PSGUSDT', 'PTRUSDT', 'PYRUSDT', 'PYTHUSDT', 'QKCUSDT', 'QNTUSDT', 'QTUMUSDT', 'QUICKUSDT', 'RACEUSDT', 'RADUSDT', 'RAYUSDT', 'RDNTUSDT', 'REBUSDT', 'REIUSDT', 'RENUSDT', 'RENDUSDT', 'REQUSDT', 'REZUSDT', 'RIFUSDT', 'RLCUSDT', 'RNDRUSDT', 'RONINUSDT', 'ROSEUSDT', 'RPLUSDT', 'RSRUSDT', 'RUNEUSDT', 'RVNUSDT', 'SAGAUSDT', 'SANDUSDT', 'SANTOSUSDT', 'SAPIEUSDT', 'SCRTUSDT', 'SCRUSDT', 'SCUSDT', 'SEIUSDT', 'SFPUSDT', 'SHELLUSDT', 'SHIBUSDT', 'SKLUSDT', 'SLPUSDT', 'SOLUSDT', 'SOLVUSDT', 'SOMIUSDT', 'SPELLUSDT', 'SPKUSDT', 'STAXUSDT', 'STGUSDT', 'STORJUSDT', 'STOUSDT', 'STRAXUSDT', 'STRKUSDT', 'STXUSDT', 'SUNUSDT', 'SUIUSDT', 'SUPERUSDT', 'SUSHIUSDT', 'SUSDT', 'SXPUSDT', 'SYRUPUSDT', 'SYSUSDT', 'TAOUSDT', 'TETRAUSDT', 'TFUELUSDT', 'THETAUSDT', 'THTUSDT', 'TIAUSDT', 'TKOUSDT', 'TLMUSDT', 'TOMUSDT', 'TOWNUSDT', 'TRBUSDT', 'TRUMPUSDT', 'TRXUSDT', 'TURBOUSDT', 'TUTUSDT', 'TWTUSDT', 'TZIOUSDT', 'UFTUSDT', 'UMAUSDT', 'UNIUSDT', 'USDCUSDT', 'USDEUSDT', 'USDPUSDT', 'USD1USDT', 'USTCUSDT', 'UTKUSDT', 'VANAUSDT', 'VCTUSDT', 'VELODROMEUSDT', 'VETUSDT', 'VICUSDT', 'VIRTUALUSDT', 'VOXELUSDT', 'WALUSDT', 'WANUSDT', 'WAVESUSDT', 'WAXPUSDT', 'WBETHUSDT', 'WBTCUSDT', 'WCTUSDT', 'WIFUSDT', 'WLDUSDT', 'WINUSDT', 'WOOUSDT', 'WRXUSDT', 'WUSDT', 'XAIUSDT', 'XECUSDT', 'XENOUSDT', 'XLMUSDT', 'XMRUSDT', 'XNOUSDT', 'XPCUSDT', 'XPLUSDT', 'XRPUSDT', 'XTZUSDT', 'XUSDUSDT', 'XVSUSDT', 'YBUSDT', 'YFIUSDT', 'YGGUSDT', 'ZECUSDT', 'ZENUSDT', 'ZILUSDT', 'ZKCUSDT', 'ZROUSDT', 'ZRXUSDT', 'ZTBUSDT', 'ZUSDT'];
        const HISTORICAL_UPDATE_INTERVAL = 60000; // Update historical data every minute
        const CANDLE_LIMIT = 100;
        const MACD_CANDLE_LIMIT = 200;
        const VOLUME_CANDLE_LIMIT = 22;
        const ATR_PERIOD = 14;
        const OBV_PERIOD = 20;
        const CORRELATION_PERIOD = 24;
        const SUPPORT_LEVELS_LIMIT = 200;
        const LEFT_BARS = 20;
        const RIGHT_BARS = 20;
        const LIQUIDITY_GRAB_LOOKBACK = 30; // Look back 30 candles for liquidity grab detection
        
        // State variables
        let cryptoData = {};
        let lastPrices = {};
        let historicalUpdateTimer = null;
        let isUpdating = false;
        let currentEMAPeriod = 20;
        let watchlists = {
            list1: { name: 'Watchlist 1', symbols: [] },
            list2: { name: 'Watchlist 2', symbols: [] },
            list3: { name: 'Watchlist 3', symbols: [] },
            list4: { name: 'Watchlist 4', symbols: [] },
            list5: { name: 'Watchlist 5', symbols: [] }
        };
        let currentView = 'all';
        let currentSymbolForLink = null;
        let btcHourlyPrices = [];
        let wsConnections = {};
        let lastUpdateTimes = {};
        const WS_UPDATE_THROTTLE = 1000; // Throttle WebSocket updates to 1 second
        let currentTimeframe = '1h'; // '1h' or '4h'
        let currentSymbolForWatchlist = null;
        
        // Filter state
        let activeFilters = {
            macd: 'all',
            crossover: 'all',
            volume: 'all',
            atr: 'all',
            obv: 'all',
            ichimoku: 'all',
            ema: 'all',
            correlation: 'all',
            support: 'all',
            flippedSupport: 'all',
            resistance: 'all',
            flippedResistance: 'all',
            liquiditySupport: 'all',
            liquidityResistance: 'all',
            cpr: 'all',
            convergence: 'all',
            resistanceConvergence: 'all' // NEW: Resistance Convergence filter
        };
        
        // DOM elements
        const tableBody = document.getElementById('table-body');
        const lastUpdatedTime = document.getElementById('last-updated-time');
        const errorMessage = document.getElementById('error-message');
        const refreshButton = document.getElementById('refresh-data');
        const viewAllBtn = document.getElementById('view-all-btn');
        const emaPeriodSelect = document.getElementById('ema-period');
        const timeframeSelect = document.getElementById('timeframe-select');
        const currentTimeframeSpan = document.querySelector('.current-timeframe');
        const watchlistCountDisplay = document.getElementById('watchlist-count-display');
        const watchlistCount = document.getElementById('watchlist-count');
        const currentWatchlistName = document.getElementById('current-watchlist-name');
        const tradingviewModal = document.getElementById('tradingview-modal');
        const tradingviewOpenAppBtn = document.getElementById('tradingview-open-app-btn');
        const tradingviewOpenWebBtn = document.getElementById('tradingview-open-web-btn');
        const tradingviewCancelBtn = document.getElementById('tradingview-cancel-btn');
        
        // Watchlist dropdown elements
        const watchlistDropdownBtn = document.getElementById('watchlist-dropdown-btn');
        const watchlistDropdownContent = document.getElementById('watchlist-dropdown-content');
        const watchlistItems = document.querySelectorAll('.watchlist-item');
        const manageWatchlistsBtn = document.getElementById('manage-watchlists-btn');
        
        // Watchlist modal elements
        const watchlistSelectionModal = document.getElementById('watchlist-selection-modal');
        const watchlistSelectionSymbol = document.getElementById('watchlist-selection-symbol');
        const watchlistSelectionList = document.getElementById('watchlist-selection-list');
        const watchlistSelectionSaveBtn = document.getElementById('watchlist-selection-save-btn');
        const watchlistSelectionCancelBtn = document.getElementById('watchlist-selection-cancel-btn');
        
        // Watchlist management modal elements
        const watchlistManagementModal = document.getElementById('watchlist-management-modal');
        const watchlistManagementList = document.getElementById('watchlist-management-list');
        const watchlistManagementSaveBtn = document.getElementById('watchlist-management-save-btn');
        const watchlistManagementCancelBtn = document.getElementById('watchlist-management-cancel-btn');
        
        // NEW: Binance Modal elements
        const binanceModal = document.getElementById('binance-modal');
        const binanceOpenAppBtn = document.getElementById('binance-open-app-btn');
        const binanceOpenWebBtn = document.getElementById('binance-open-web-btn');
        const binanceCancelBtn = document.getElementById('binance-cancel-btn');
        
        // Filter DOM elements
        const filterPanelToggle = document.getElementById('filter-panel-toggle');
        const filterPanel = document.getElementById('filter-panel');
        const filterPanelIcon = document.getElementById('filter-panel-icon');
        const applyFiltersBtn = document.getElementById('apply-filters');
        const resetFiltersBtn = document.getElementById('reset-filters');
        const clearFiltersBtn = document.getElementById('clear-filters');
        const activeFiltersContainer = document.getElementById('active-filters-container');
        const activeFiltersList = document.getElementById('active-filters-list');
        const filterResults = document.getElementById('filter-results');
        
        // Filter select elements
        const filterMacd = document.getElementById('filter-macd');
        const filterCrossover = document.getElementById('filter-crossover');
        const filterVolume = document.getElementById('filter-volume');
        const filterAtr = document.getElementById('filter-atr');
        const filterObv = document.getElementById('filter-obv');
        const filterIchimoku = document.getElementById('filter-ichimoku');
        const filterEma = document.getElementById('filter-ema');
        const filterCorrelation = document.getElementById('filter-correlation');
        const filterSupport = document.getElementById('filter-support');
        const filterFlippedSupport = document.getElementById('filter-flipped-support');
        const filterResistance = document.getElementById('filter-resistance');
        const filterFlippedResistance = document.getElementById('filter-flipped-resistance');
        const filterLiquiditySupport = document.getElementById('filter-liquidity-support');
        const filterLiquidityResistance = document.getElementById('filter-liquidity-resistance');
        const filterCpr = document.getElementById('filter-cpr');
        const filterConvergence = document.getElementById('filter-convergence');
        const filterResistanceConvergence = document.getElementById('filter-resistance-convergence'); // NEW
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadWatchlists();
            
            // Initialize filter panel
            filterPanelToggle.addEventListener('click', toggleFilterPanel);
            applyFiltersBtn.addEventListener('click', applyFilters);
            resetFiltersBtn.addEventListener('click', resetFilters);
            clearFiltersBtn.addEventListener('click', clearFilters);
            
            // Add change listeners to filter selects
            const filterSelects = document.querySelectorAll('.filter-select');
            filterSelects.forEach(select => {
                select.addEventListener('change', function() {
                    // Update active filters object
                    const filterId = this.id.replace('filter-', '');
                    activeFilters[filterId] = this.value;
                    
                    // Apply filters immediately when changed
                    applyFilters();
                });
            });
            
            // Watchlist dropdown functionality
            watchlistDropdownBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                watchlistDropdownContent.classList.toggle('show');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function() {
                watchlistDropdownContent.classList.remove('show');
            });
            
            // Watchlist item click handlers
            watchlistItems.forEach(item => {
                item.addEventListener('click', function() {
                    const watchlistId = this.getAttribute('data-watchlist');
                    selectWatchlist(watchlistId);
                    watchlistDropdownContent.classList.remove('show');
                });
            });
            
            // Manage watchlists button
            manageWatchlistsBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                showWatchlistManagementModal();
                watchlistDropdownContent.classList.remove('show');
            });
            
            viewAllBtn.addEventListener('click', function() {
                setActiveView('all');
                updateTable();
                applyFilters(); // Re-apply filters after view change
            });
            
            emaPeriodSelect.addEventListener('change', function() {
                currentEMAPeriod = parseInt(this.value);
                Object.keys(cryptoData).forEach(symbol => {
                    if (cryptoData[symbol].indicatorKlines) {
                        const emaAnalysis = calculateEMAAnalysis(cryptoData[symbol].indicatorKlines, cryptoData[symbol].currentPrice, currentEMAPeriod);
                        cryptoData[symbol].emaAnalysis = emaAnalysis;
                        cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(cryptoData[symbol], cryptoData[symbol].currentPrice);
                    }
                });
                updateTable();
                applyFilters(); // Re-apply filters after EMA period change
            });
            
            timeframeSelect.addEventListener('change', function() {
                currentTimeframe = this.value;
                updateTimeframeDisplay();
                clearInterval(historicalUpdateTimer);
                fetchAllHistoricalData();
                historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            });
            
            // TradingView modal event listeners
            tradingviewOpenAppBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openTradingViewApp(currentSymbolForLink);
                    hideTradingViewModal();
                }
            });
            
            tradingviewOpenWebBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openTradingViewWeb(currentSymbolForLink);
                    hideTradingViewModal();
                }
            });
            
            tradingviewCancelBtn.addEventListener('click', function() {
                hideTradingViewModal();
            });
            
            tradingviewModal.addEventListener('click', function(e) {
                if (e.target === tradingviewModal) {
                    hideTradingViewModal();
                }
            });
            
            // Watchlist selection modal event listeners
            watchlistSelectionSaveBtn.addEventListener('click', saveWatchlistSelection);
            watchlistSelectionCancelBtn.addEventListener('click', hideWatchlistSelectionModal);
            
            watchlistSelectionModal.addEventListener('click', function(e) {
                if (e.target === watchlistSelectionModal) {
                    hideWatchlistSelectionModal();
                }
            });
            
            // Watchlist management modal event listeners
            watchlistManagementSaveBtn.addEventListener('click', saveWatchlistManagement);
            watchlistManagementCancelBtn.addEventListener('click', hideWatchlistManagementModal);
            
            watchlistManagementModal.addEventListener('click', function(e) {
                if (e.target === watchlistManagementModal) {
                    hideWatchlistManagementModal();
                }
            });
            
            // NEW: Binance modal event listeners
            binanceOpenAppBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openBinanceApp(currentSymbolForLink);
                    hideBinanceModal();
                }
            });
            
            binanceOpenWebBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openBinanceWeb(currentSymbolForLink);
                    hideBinanceModal();
                }
            });
            
            binanceCancelBtn.addEventListener('click', function() {
                hideBinanceModal();
            });
            
            binanceModal.addEventListener('click', function(e) {
                if (e.target === binanceModal) {
                    hideBinanceModal();
                }
            });
            
            tableBody.addEventListener('click', function(event) {
                if (event.target.closest('.watchlist-star') || event.target.classList.contains('watchlist-star')) {
                    const starElement = event.target.closest('.watchlist-star') || event.target;
                    const symbol = starElement.getAttribute('data-symbol');
                    if (symbol) {
                        showWatchlistSelectionModal(symbol);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                if (event.target.closest('.crypto-link') || event.target.classList.contains('crypto-link')) {
                    const linkElement = event.target.closest('.crypto-link') || event.target;
                    const symbolMatch = linkElement.id ? linkElement.id.match(/link-(.+)/) : null;
                    if (symbolMatch && symbolMatch[1]) {
                        const symbol = symbolMatch[1];
                        handleTradingViewClick(symbol, event);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                // NEW: Handle Binance link clicks
                if (event.target.closest('.binance-link') || event.target.classList.contains('binance-link')) {
                    const linkElement = event.target.closest('.binance-link') || event.target;
                    const symbolMatch = linkElement.id ? linkElement.id.match(/binance-link-(.+)/) : null;
                    if (symbolMatch && symbolMatch[1]) {
                        const symbol = symbolMatch[1];
                        handleBinanceClick(symbol, event);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
            
            fetchAllHistoricalData();
            
            historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            
            refreshButton.addEventListener('click', function() {
                clearInterval(historicalUpdateTimer);
                fetchAllHistoricalData();
                historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            });
            
            setInterval(updateTimeDisplay, 1000);
            
            updateWatchlistCounts();
        });
        
        // Load watchlists from localStorage
        function loadWatchlists() {
            const savedWatchlists = localStorage.getItem('cryptoWatchlists');
            if (savedWatchlists) {
                try {
                    const parsedWatchlists = JSON.parse(savedWatchlists);
                    // Merge with default watchlists
                    for (const key in parsedWatchlists) {
                        if (watchlists[key]) {
                            watchlists[key].name = parsedWatchlists[key].name || watchlists[key].name;
                            watchlists[key].symbols = parsedWatchlists[key].symbols || [];
                        }
                    }
                } catch (e) {
                    console.error('Error loading watchlists:', e);
                }
            }
        }
        
        // Save watchlists to localStorage
        function saveWatchlists() {
            localStorage.setItem('cryptoWatchlists', JSON.stringify(watchlists));
        }
        
        // Update watchlist counts in the UI
        function updateWatchlistCounts() {
            // Update counts in dropdown
            document.getElementById('watchlist-all-count').textContent = SYMBOLS.length;
            
            for (const key in watchlists) {
                const countElement = document.getElementById(`watchlist-${key}-count`);
                if (countElement) {
                    countElement.textContent = watchlists[key].symbols.length;
                }
            }
            
            // Update current watchlist count display
            updateCurrentWatchlistCount();
        }
        
        // Update current watchlist count display
        function updateCurrentWatchlistCount() {
            if (currentView === 'all') {
                watchlistCount.textContent = SYMBOLS.length;
                currentWatchlistName.textContent = 'All Coins';
            } else if (watchlists[currentView]) {
                watchlistCount.textContent = watchlists[currentView].symbols.length;
                currentWatchlistName.textContent = watchlists[currentView].name;
            }
            
            // Show/hide watchlist count display
            if (currentView === 'all' || watchlists[currentView].symbols.length > 0) {
                watchlistCountDisplay.style.display = 'inline-block';
            } else {
                watchlistCountDisplay.style.display = 'none';
            }
        }
        
        // Select a watchlist to view
        function selectWatchlist(watchlistId) {
            // Update active state in dropdown
            watchlistItems.forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('data-watchlist') === watchlistId) {
                    item.classList.add('active');
                }
            });
            
            // Set active view
            if (watchlistId === 'all') {
                setActiveView('all');
            } else {
                setActiveView(watchlistId);
            }
            
            updateTable();
            applyFilters(); // Re-apply filters after view change
        }
        
        // Set active view
        function setActiveView(view) {
            currentView = view;
            
            if (view === 'all') {
                viewAllBtn.classList.add('active');
                viewAllBtn.innerHTML = '<i class="fas fa-coins"></i> All Coins';
            } else {
                viewAllBtn.classList.remove('active');
                viewAllBtn.innerHTML = '<i class="fas fa-coins"></i> All Coins';
            }
            
            updateCurrentWatchlistCount();
        }
        
        // Show watchlist selection modal
        function showWatchlistSelectionModal(symbol) {
            currentSymbolForWatchlist = symbol;
            watchlistSelectionSymbol.textContent = `Add ${symbol} to watchlists:`;
            
            // Clear previous list
            watchlistSelectionList.innerHTML = '';
            
            // Get which watchlists the symbol is already in
            const symbolWatchlists = getWatchlistsForSymbol(symbol);
            
            // Create checkboxes for each watchlist
            for (const key in watchlists) {
                const watchlist = watchlists[key];
                const isChecked = symbolWatchlists.includes(key);
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'watchlist-selection-item';
                itemDiv.innerHTML = `
                    <div class="watchlist-selection-label">
                        <input type="checkbox" class="watchlist-selection-checkbox" id="watchlist-check-${key}" ${isChecked ? 'checked' : ''}>
                        <label for="watchlist-check-${key}" class="watchlist-selection-name">${watchlist.name}</label>
                    </div>
                    <span class="watchlist-selection-count">${watchlist.symbols.length} coins</span>
                `;
                
                watchlistSelectionList.appendChild(itemDiv);
            }
            
            // Show the modal
            watchlistSelectionModal.style.display = 'flex';
        }
        
        // Hide watchlist selection modal
        function hideWatchlistSelectionModal() {
            watchlistSelectionModal.style.display = 'none';
            currentSymbolForWatchlist = null;
        }
        
        // Save watchlist selection
        function saveWatchlistSelection() {
            if (!currentSymbolForWatchlist) return;
            
            // Get all checked watchlists
            const checkboxes = document.querySelectorAll('.watchlist-selection-checkbox');
            const selectedWatchlists = [];
            
            checkboxes.forEach(checkbox => {
                const watchlistId = checkbox.id.replace('watchlist-check-', '');
                if (checkbox.checked) {
                    selectedWatchlists.push(watchlistId);
                }
            });
            
            // Update symbol in watchlists
            for (const key in watchlists) {
                const watchlist = watchlists[key];
                const symbolIndex = watchlist.symbols.indexOf(currentSymbolForWatchlist);
                
                if (selectedWatchlists.includes(key)) {
                    // Add symbol if not already present
                    if (symbolIndex === -1) {
                        watchlist.symbols.push(currentSymbolForWatchlist);
                    }
                } else {
                    // Remove symbol if present
                    if (symbolIndex !== -1) {
                        watchlist.symbols.splice(symbolIndex, 1);
                    }
                }
            }
            
            // Save to localStorage
            saveWatchlists();
            
            // Update UI
            updateWatchlistCounts();
            updateStarIcon(currentSymbolForWatchlist);
            
            // Update table if viewing a watchlist
            if (currentView !== 'all') {
                updateTable();
                applyFilters();
            }
            
            // Hide modal
            hideWatchlistSelectionModal();
        }
        
        // Get which watchlists a symbol is in
        function getWatchlistsForSymbol(symbol) {
            const watchlistIds = [];
            for (const key in watchlists) {
                if (watchlists[key].symbols.includes(symbol)) {
                    watchlistIds.push(key);
                }
            }
            return watchlistIds;
        }
        
        // Update star icon for a specific symbol
        function updateStarIcon(symbol) {
            const starElement = document.querySelector(`.watchlist-star[data-symbol="${symbol}"]`);
            if (starElement) {
                const watchlistIds = getWatchlistsForSymbol(symbol);
                if (watchlistIds.length > 0) {
                    starElement.classList.add('active');
                    starElement.innerHTML = '<i class="fas fa-star"></i>';
                    // Add title with watchlist names
                    const watchlistNames = watchlistIds.map(id => watchlists[id].name).join(', ');
                    starElement.title = `In watchlists: ${watchlistNames}`;
                } else {
                    starElement.classList.remove('active');
                    starElement.innerHTML = '<i class="far fa-star"></i>';
                    starElement.title = 'Add to watchlists';
                }
            }
        }
        
        // Show watchlist management modal
        function showWatchlistManagementModal() {
            // Clear previous list
            watchlistManagementList.innerHTML = '';
            
            // Create input fields for each watchlist
            for (const key in watchlists) {
                const watchlist = watchlists[key];
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'watchlist-management-item';
                itemDiv.innerHTML = `
                    <input type="text" class="watchlist-management-input" id="watchlist-input-${key}" value="${watchlist.name}" maxlength="20">
                    <span class="watchlist-management-count">${watchlist.symbols.length} coins</span>
                `;
                
                watchlistManagementList.appendChild(itemDiv);
            }
            
            // Show the modal
            watchlistManagementModal.style.display = 'flex';
        }
        
        // Hide watchlist management modal
        function hideWatchlistManagementModal() {
            watchlistManagementModal.style.display = 'none';
        }
        
        // Save watchlist management changes
        function saveWatchlistManagement() {
            // Update watchlist names
            for (const key in watchlists) {
                const input = document.getElementById(`watchlist-input-${key}`);
                if (input) {
                    const newName = input.value.trim();
                    if (newName) {
                        watchlists[key].name = newName;
                    }
                }
            }
            
            // Save to localStorage
            saveWatchlists();
            
            // Update UI
            updateWatchlistDropdownNames();
            updateCurrentWatchlistCount();
            
            // Hide modal
            hideWatchlistManagementModal();
        }
        
        // Update watchlist names in dropdown
        function updateWatchlistDropdownNames() {
            for (const key in watchlists) {
                const watchlistItem = document.querySelector(`.watchlist-item[data-watchlist="${key}"] span:first-child`);
                if (watchlistItem) {
                    watchlistItem.textContent = watchlists[key].name;
                }
            }
        }
        
        // Toggle filter panel visibility
        function toggleFilterPanel() {
            filterPanel.classList.toggle('collapsed');
            filterPanelIcon.classList.toggle('rotated');
        }
        
        // Apply filters to the table
        function applyFilters() {
            // Get all filter values
            activeFilters = {
                macd: filterMacd.value,
                crossover: filterCrossover.value,
                volume: filterVolume.value,
                atr: filterAtr.value,
                obv: filterObv.value,
                ichimoku: filterIchimoku.value,
                ema: filterEma.value,
                correlation: filterCorrelation.value,
                support: filterSupport.value,
                flippedSupport: filterFlippedSupport.value,
                resistance: filterResistance.value,
                flippedResistance: filterFlippedResistance.value,
                liquiditySupport: filterLiquiditySupport.value,
                liquidityResistance: filterLiquidityResistance.value,
                cpr: filterCpr.value,
                convergence: filterConvergence.value,
                resistanceConvergence: filterResistanceConvergence.value // NEW
            };
            
            // Update active filters display
            updateActiveFiltersDisplay();
            
            // Get all table rows with data
            const rows = tableBody.querySelectorAll('tr[data-symbol]');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const symbol = row.getAttribute('data-symbol');
                const data = cryptoData[symbol];
                
                if (!data) {
                    row.style.display = 'none';
                    return;
                }
                
                // Check if row passes all filters
                let passesFilters = true;
                
                // MACD filter
                if (activeFilters.macd !== 'all') {
                    const macdStatus = data.macdAnalysis?.status || 'neutral';
                    const macdText = macdStatus.charAt(0).toUpperCase() + macdStatus.slice(1);
                    if (macdText !== activeFilters.macd) {
                        passesFilters = false;
                    }
                }
                
                // MACD Crossover filter
                if (passesFilters && activeFilters.crossover !== 'all') {
                    const crossoverType = data.macdAnalysis?.crossover || 'none';
                    let crossoverText = 'None';
                    if (crossoverType === 'bullish') crossoverText = 'Bullish Crossover';
                    else if (crossoverType === 'bearish') crossoverText = 'Bearish Crossover';
                    
                    if (crossoverText !== activeFilters.crossover) {
                        passesFilters = false;
                    }
                }
                
                // Volume Spike filter
                if (passesFilters && activeFilters.volume !== 'all') {
                    const hasVolumeSpike = data.volumeSpike?.spike || false;
                    const volumeText = hasVolumeSpike ? 'Spike' : 'Normal';
                    if (volumeText !== activeFilters.volume) {
                        passesFilters = false;
                    }
                }
                
                // ATR Volatility filter
                if (passesFilters && activeFilters.atr !== 'all') {
                    const atrVolatility = data.atrAnalysis?.volatility || 'low';
                    const atrText = atrVolatility.charAt(0).toUpperCase() + atrVolatility.slice(1);
                    if (atrText !== activeFilters.atr) {
                        passesFilters = false;
                    }
                }
                
                // OBV filter
                if (passesFilters && activeFilters.obv !== 'all') {
                    const obvTrend = data.obvAnalysis?.trend || 'neutral';
                    let obvText = 'None';
                    if (obvTrend === 'rising') obvText = 'Rising Volume';
                    else if (obvTrend === 'falling') obvText = 'Declining Volume';
                    
                    if (obvText !== activeFilters.obv) {
                        passesFilters = false;
                    }
                }
                
                // Ichimoku Cloud filter
                if (passesFilters && activeFilters.ichimoku !== 'all') {
                    const ichimokuPosition = data.ichimokuAnalysis?.cloudPosition || 'inside';
                    const ichimokuText = ichimokuPosition.charAt(0).toUpperCase() + ichimokuPosition.slice(1) + ' Cloud';
                    if (ichimokuText !== activeFilters.ichimoku) {
                        passesFilters = false;
                    }
                }
                
                // EMA filter
                if (passesFilters && activeFilters.ema !== 'all') {
                    const emaPosition = data.emaAnalysis?.position || 'cross';
                    let emaText = 'Near EMA';
                    if (emaPosition === 'above') emaText = 'Above EMA';
                    else if (emaPosition === 'below') emaText = 'Below EMA';
                    
                    if (emaText !== activeFilters.ema) {
                        passesFilters = false;
                    }
                }
                
                // Correlation filter
                if (passesFilters && activeFilters.correlation !== 'all') {
                    const correlationStrength = data.correlationWithBTC?.strength || 'unknown';
                    const correlationText = correlationStrength.charAt(0).toUpperCase() + correlationStrength.slice(1);
                    if (correlationText !== activeFilters.correlation) {
                        passesFilters = false;
                    }
                }
                
                // Support Level filter
                if (passesFilters && activeFilters.support !== 'all') {
                    const hasSupport = (data.supportLevels && data.supportLevels.length > 0) || false;
                    const supportText = hasSupport ? 'Has Support' : 'No Support';
                    if (supportText !== activeFilters.support) {
                        passesFilters = false;
                    }
                }
                
                // Flipped Support filter
                if (passesFilters && activeFilters.flippedSupport !== 'all') {
                    const hasFlippedSupport = (data.flippedLevels && data.flippedLevels.length > 0) || false;
                    const flippedSupportText = hasFlippedSupport ? 'Has Flipped Support' : 'No Flipped Support';
                    if (flippedSupportText !== activeFilters.flippedSupport) {
                        passesFilters = false;
                    }
                }
                
                // Resistance Level filter
                if (passesFilters && activeFilters.resistance !== 'all') {
                    const hasResistance = (data.resistanceLevels && data.resistanceLevels.length > 0) || false;
                    const resistanceText = hasResistance ? 'Has Resistance' : 'No Resistance';
                    if (resistanceText !== activeFilters.resistance) {
                        passesFilters = false;
                    }
                }
                
                // Flipped Resistance filter
                if (passesFilters && activeFilters.flippedResistance !== 'all') {
                    const hasFlippedResistance = (data.flippedResistanceLevels && data.flippedResistanceLevels.length > 0) || false;
                    const flippedResistanceText = hasFlippedResistance ? 'Has Flipped Resistance' : 'No Flipped Resistance';
                    if (flippedResistanceText !== activeFilters.flippedResistance) {
                        passesFilters = false;
                    }
                }
                
                // Liquidity Grab Support filter
                if (passesFilters && activeFilters.liquiditySupport !== 'all') {
                    const hasLiquiditySupport = data.liquidityGrabSupport?.detected || false;
                    const liquiditySupportText = hasLiquiditySupport ? 'Yes' : 'No';
                    if (liquiditySupportText !== activeFilters.liquiditySupport) {
                        passesFilters = false;
                    }
                }
                
                // Liquidity Grab Resistance filter
                if (passesFilters && activeFilters.liquidityResistance !== 'all') {
                    const hasLiquidityResistance = data.liquidityGrabResistance?.detected || false;
                    const liquidityResistanceText = hasLiquidityResistance ? 'Yes' : 'No';
                    if (liquidityResistanceText !== activeFilters.liquidityResistance) {
                        passesFilters = false;
                    }
                }
                
                // CPR filter
                if (passesFilters && activeFilters.cpr !== 'all') {
                    const cprPosition = data.cprAnalysis?.position || 'inside';
                    let cprText = 'Inside CPR';
                    if (cprPosition === 'above') cprText = 'Above CPR';
                    else if (cprPosition === 'below') cprText = 'Below CPR';
                    
                    if (cprText !== activeFilters.cpr) {
                        passesFilters = false;
                    }
                }
                
                // Support Convergence filter
                if (passesFilters && activeFilters.convergence !== 'all') {
                    const hasConvergence = data.supportConvergence?.status === 'Solid Support' || false;
                    const convergenceText = hasConvergence ? 'Solid Support' : 'No Convergence';
                    if (convergenceText !== activeFilters.convergence) {
                        passesFilters = false;
                    }
                }
                
                // NEW: Resistance Convergence filter
                if (passesFilters && activeFilters.resistanceConvergence !== 'all') {
                    const hasResistanceConvergence = data.resistanceConvergence?.status === 'Solid Resistance' || false;
                    const resistanceConvergenceText = hasResistanceConvergence ? 'Solid Resistance' : 'No Convergence';
                    if (resistanceConvergenceText !== activeFilters.resistanceConvergence) {
                        passesFilters = false;
                    }
                }
                
                // Show or hide the row based on filter results
                if (passesFilters) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter results display
            updateFilterResults(visibleCount, rows.length);
            
            // Show/hide active filters container
            const hasActiveFilters = Object.values(activeFilters).some(filter => filter !== 'all');
            activeFiltersContainer.style.display = hasActiveFilters ? 'flex' : 'none';
        }
        
        // Update active filters display
        function updateActiveFiltersDisplay() {
            activeFiltersList.innerHTML = '';
            
            Object.keys(activeFilters).forEach(filterKey => {
                if (activeFilters[filterKey] !== 'all') {
                    const filterName = filterKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const filterValue = activeFilters[filterKey];
                    
                    const filterTag = document.createElement('div');
                    filterTag.className = 'active-filter-tag';
                    filterTag.innerHTML = `
                        ${filterName}: ${filterValue}
                        <i class="fas fa-times" data-filter="${filterKey}"></i>
                    `;
                    
                    // Add click event to remove individual filter
                    const removeBtn = filterTag.querySelector('i');
                    removeBtn.addEventListener('click', function() {
                        const filterToRemove = this.getAttribute('data-filter');
                        resetSingleFilter(filterToRemove);
                    });
                    
                    activeFiltersList.appendChild(filterTag);
                }
            });
        }
        
        // Reset a single filter
        function resetSingleFilter(filterKey) {
            const filterElement = document.getElementById(`filter-${filterKey}`);
            if (filterElement) {
                filterElement.value = 'all';
                activeFilters[filterKey] = 'all';
                applyFilters();
            }
        }
        
        // Reset all filters
        function resetFilters() {
            const filterSelects = document.querySelectorAll('.filter-select');
            filterSelects.forEach(select => {
                select.value = 'all';
            });
            
            // Reset active filters object
            Object.keys(activeFilters).forEach(key => {
                activeFilters[key] = 'all';
            });
            
            applyFilters();
        }
        
        // Clear all filters (same as reset)
        function clearFilters() {
            resetFilters();
        }
        
        // Update filter results display
        function updateFilterResults(visible, total) {
            if (visible === total) {
                filterResults.textContent = `Showing all ${total} coins`;
            } else {
                filterResults.textContent = `Showing ${visible} of ${total} coins`;
            }
        }
        
        // Update timeframe display
        function updateTimeframeDisplay() {
            const timeframeText = currentTimeframe === '1h' ? '1 Hour Timeframe' : '4 Hour Timeframe';
            currentTimeframeSpan.textContent = `(${timeframeText})`;
            
            // Update table headers based on timeframe
            updateTableHeaders();
        }
        
        // Update table headers based on timeframe
        function updateTableHeaders() {
            const headers = document.querySelectorAll('th');
            if (headers.length >= 24) {
                // Update MACD header
                if (currentTimeframe === '1h') {
                    headers[2].innerHTML = '<i class="fas fa-chart-bar"></i> MACD (1h)';
                    headers[4].innerHTML = '<i class="fas fa-chart-line"></i> Volatility ATR (4h)';
                    headers[6].innerHTML = '<i class="fas fa-balance-scale"></i> OBV (1h)';
                } else {
                    headers[2].innerHTML = '<i class="fas fa-chart-bar"></i> MACD (4h)';
                    headers[4].innerHTML = '<i class="fas fa-chart-line"></i> Volatility ATR (12h)';
                    headers[6].innerHTML = '<i class="fas fa-balance-scale"></i> OBV (4h)';
                }
            }
        }
        
        // Pivot detection functions
        function pivotHigh(highs, index, left, right) {
            if (index < left || index >= highs.length - right) return false;
            
            const currentHigh = highs[index];
            for (let i = index - left; i <= index + right; i++) {
                if (i === index) continue;
                if (highs[i] >= currentHigh) return false;
            }
            return true;
        }
        
        function pivotLow(lows, index, left, right) {
            if (index < left || index >= lows.length - right) return false;
            
            const currentLow = lows[index];
            for (let i = index - left; i <= index + right; i++) {
                if (i === index) continue;
                if (lows[i] <= currentLow) return false;
            }
            return true;
        }
        
        // Calculate market structure (Support Levels, Flipped Support, Resistance Levels, Flipped Resistance)
        function calculateMarketStructure(klines, currentPrice) {
            if (!klines || klines.length < 50) {
                return { 
                    supportLevels: [], 
                    flippedLevels: [],
                    resistanceLevels: [],
                    flippedResistanceLevels: [] 
                };
            }
            
            const highs = klines.map(c => parseFloat(c.high));
            const lows = klines.map(c => parseFloat(c.low));
            
            const ph = new Array(klines.length).fill(false);
            const pl = new Array(klines.length).fill(false);
            const hl = new Array(klines.length).fill(null);
            const zz = new Array(klines.length).fill(null);
            
            for (let i = LEFT_BARS; i < klines.length - RIGHT_BARS; i++) {
                ph[i] = pivotHigh(highs, i, LEFT_BARS, RIGHT_BARS);
                pl[i] = pivotLow(lows, i, LEFT_BARS, RIGHT_BARS);
                
                if (ph[i]) {
                    hl[i] = 1;
                    zz[i] = highs[i];
                } else if (pl[i]) {
                    hl[i] = -1;
                    zz[i] = lows[i];
                }
            }
            
            const filteredZZ = [...zz];
            const filteredHL = [...hl];
            
            const supports = [];
            const flippedSupports = [];
            const resistances = [];
            const flippedResistances = [];
            
            for (let i = 0; i < klines.length; i++) {
                if (filteredZZ[i] !== null && filteredHL[i] === -1) {
                    if (currentPrice > filteredZZ[i]) {
                        supports.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'LL/HL'
                        });
                    } else {
                        // This is a pivot low above current price - potential resistance
                        flippedResistances.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'LL/HL',
                            breached: true
                        });
                    }
                } else if (filteredZZ[i] !== null && filteredHL[i] === 1) {
                    if (currentPrice < filteredZZ[i]) {
                        resistances.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'HH/LH'
                        });
                    } else {
                        // This is a pivot high below current price - potential support
                        flippedSupports.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'HH/LH',
                            breached: true
                        });
                    }
                }
            }
            
            supports.sort((a, b) => b.price - a.price);
            flippedSupports.sort((a, b) => b.price - a.price);
            resistances.sort((a, b) => a.price - b.price);
            flippedResistances.sort((a, b) => a.price - b.price);
            
            const uniqueSupports = [];
            const uniqueFlipped = [];
            const uniqueResistances = [];
            const uniqueFlippedResistances = [];
            
            supports.forEach(s => {
                if (!uniqueSupports.find(us => Math.abs(us.price - s.price) / s.price < 0.005)) {
                    uniqueSupports.push(s);
                }
            });
            
            flippedSupports.forEach(f => {
                if (!uniqueFlipped.find(uf => Math.abs(uf.price - f.price) / f.price < 0.005)) {
                    uniqueFlipped.push(f);
                }
            });
            
            resistances.forEach(r => {
                if (!uniqueResistances.find(ur => Math.abs(ur.price - r.price) / r.price < 0.005)) {
                    uniqueResistances.push(r);
                }
            });
            
            flippedResistances.forEach(fr => {
                if (!uniqueFlippedResistances.find(ufr => Math.abs(ufr.price - fr.price) / fr.price < 0.005)) {
                    uniqueFlippedResistances.push(fr);
                }
            });
            
            const closestSupports = uniqueSupports
                .map(s => ({
                    ...s,
                    distance: Math.abs(s.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestFlipped = uniqueFlipped
                .map(f => ({
                    ...f,
                    distance: Math.abs(f.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestResistances = uniqueResistances
                .map(r => ({
                    ...r,
                    distance: Math.abs(r.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestFlippedResistances = uniqueFlippedResistances
                .map(fr => ({
                    ...fr,
                    distance: Math.abs(fr.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            return {
                supportLevels: closestSupports,
                flippedLevels: closestFlipped,
                resistanceLevels: closestResistances,
                flippedResistanceLevels: closestFlippedResistances
            };
        }
        
        // Calculate Liquidity Grab (Support)
        function calculateLiquidityGrabSupport(supportLevels, klines, currentPrice) {
            if (!supportLevels || supportLevels.length === 0 || !klines || klines.length < LIQUIDITY_GRAB_LOOKBACK) {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Insufficient data'
                };
            }
            
            // Get the last LIQUIDITY_GRAB_LOOKBACK candles for analysis
            const recentCandles = klines.slice(-LIQUIDITY_GRAB_LOOKBACK);
            
            let detectedGrab = null;
            let grabLevel = null;
            
            // Check each support level for liquidity grab pattern
            for (const support of supportLevels) {
                let breached = false;
                let reclaimed = false;
                let breachIndex = -1;
                let reclaimIndex = -1;
                
                // Check recent candles for breach and reclaim pattern
                for (let i = 0; i < recentCandles.length; i++) {
                    const candle = recentCandles[i];
                    
                    // Check if candle closed below support level (breach)
                    if (!breached && candle.close < support.price) {
                        breached = true;
                        breachIndex = i;
                    }
                    
                    // Check if after breach, candle closed above support level (reclaim)
                    if (breached && !reclaimed && candle.close > support.price && i > breachIndex) {
                        reclaimed = true;
                        reclaimIndex = i;
                    }
                }
                
                // If both breach and reclaim happened, we have a liquidity grab
                if (breached && reclaimed) {
                    // Check if current price is still above the support level (respected after reclaim)
                    if (currentPrice > support.price) {
                        detectedGrab = support;
                        break;
                    }
                }
            }
            
            if (detectedGrab) {
                return {
                    detected: true,
                    level: detectedGrab,
                    price: detectedGrab.price,
                    details: `Support at $${formatNumber(detectedGrab.price)} was breached and then reclaimed`
                };
            } else {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'No liquidity grab detected for support levels'
                };
            }
        }
        
        // Calculate Liquidity Grab (Resistance)
        function calculateLiquidityGrabResistance(resistanceLevels, klines, currentPrice) {
            if (!resistanceLevels || resistanceLevels.length === 0 || !klines || klines.length < LIQUIDITY_GRAB_LOOKBACK) {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Insufficient data'
                };
            }
            
            // Get the last LIQUIDITY_GRAB_LOOKBACK candles for analysis
            const recentCandles = klines.slice(-LIQUIDITY_GRAB_LOOKBACK);
            
            let detectedGrab = null;
            let grabLevel = null;
            
            // Check each resistance level for liquidity grab pattern
            for (const resistance of resistanceLevels) {
                let breached = false;
                let reclaimed = false;
                let breachIndex = -1;
                let reclaimIndex = -1;
                
                // Check recent candles for breach and reclaim pattern
                for (let i = 0; i < recentCandles.length; i++) {
                    const candle = recentCandles[i];
                    
                    // Check if candle closed above resistance level (breach)
                    if (!breached && candle.close > resistance.price) {
                        breached = true;
                        breachIndex = i;
                    }
                    
                    // Check if after breach, candle closed below resistance level (reclaim)
                    if (breached && !reclaimed && candle.close < resistance.price && i > breachIndex) {
                        reclaimed = true;
                        reclaimIndex = i;
                    }
                }
                
                // If both breach and reclaim happened, we have a liquidity grab
                if (breached && reclaimed) {
                    // Check if current price is still below the resistance level (respected after reclaim)
                    if (currentPrice < resistance.price) {
                        detectedGrab = resistance;
                        break;
                    }
                }
            }
            
            if (detectedGrab) {
                return {
                    detected: true,
                    level: detectedGrab,
                    price: detectedGrab.price,
                    details: `Resistance at $${formatNumber(detectedGrab.price)} was breached and then reclaimed`
                };
            } else {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'No liquidity grab detected for resistance levels'
                };
            }
        }
        
        // Format price with appropriate decimals
        function formatPriceForLevels(price) {
            if (price >= 1000) return price.toFixed(2);
            if (price >= 100) return price.toFixed(3);
            if (price >= 10) return price.toFixed(4);
            if (price >= 1) return price.toFixed(5);
            if (price >= 0.1) return price.toFixed(6);
            return price.toFixed(8);
        }
        
        // Format percentage for levels
        function formatPercentForLevels(price, currentPrice) {
            const percent = ((price - currentPrice) / currentPrice * 100);
            return {
                value: Math.abs(percent).toFixed(2),
                isPositive: percent >= 0
            };
        }
        
        // Calculate Daily CPR (Central Pivot Range) - Using EXACT PineScript formulas
        function calculateDailyCPR(dailyKlines, currentPrice) {
            if (!dailyKlines || dailyKlines.length < 2) {
                return {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'insufficient data',
                    priceVsCPR: 0,
                    range: 0
                };
            }
            
            // IMPORTANT: The PineScript indicator uses PREVIOUS DAY'S data for today's CPR
            // The PineScript uses: request.security(syminfo.tickerid, 'D', pivot[1], ...)
            // The [1] means previous bar in PineScript, so we need the previous day's data
            // The dailyKlines array is in chronological order (oldest first)
            // We need the second to last candle (index dailyKlines.length - 2) for previous day
            
            let prevDayIndex = dailyKlines.length - 2;
            
            // Safety check: if we don't have at least 2 days, use the oldest we have
            if (prevDayIndex < 0) {
                prevDayIndex = 0;
            }
            
            const prevDay = dailyKlines[prevDayIndex];
            
            const high = parseFloat(prevDay.high);
            const low = parseFloat(prevDay.low);
            const close = parseFloat(prevDay.close);
            
            // EXACT formulas from PineScript - must match exactly
            const pivot = (high + low + close) / 3;  // Central Pivot (CP)
            const bc = (high + low) / 2;             // Bottom Central (BC)
            const tc = pivot - bc + pivot;           // Top Central (TC)
            
            // Calculate additional support and resistance levels (for reference)
            const s1 = pivot * 2 - high;
            const s2 = pivot - (high - low);
            const s3 = low - 2 * (high - pivot);
            const r1 = pivot * 2 - low;
            const r2 = pivot + (high - low);
            const r3 = high + 2 * (pivot - low);
            
            // Determine position relative to CPR
            let position = 'inside';
            let priceVsCPR = 0;
            let range = tc - bc;
            
            if (currentPrice > tc) {
                position = 'above';
                priceVsCPR = ((currentPrice - tc) / tc) * 100;
            } else if (currentPrice < bc) {
                position = 'below';
                priceVsCPR = ((bc - currentPrice) / currentPrice) * 100;
            } else {
                position = 'inside';
                // Calculate how far inside the CPR (percentage from BC to TC)
                if (range > 0) {
                    priceVsCPR = ((currentPrice - bc) / range) * 100;
                }
            }
            
            return {
                tc: parseFloat(tc.toFixed(4)),
                cp: parseFloat(pivot.toFixed(4)),
                bc: parseFloat(bc.toFixed(4)),
                s1: parseFloat(s1.toFixed(4)),
                s2: parseFloat(s2.toFixed(4)),
                s3: parseFloat(s3.toFixed(4)),
                r1: parseFloat(r1.toFixed(4)),
                r2: parseFloat(r2.toFixed(4)),
                r3: parseFloat(r3.toFixed(4)),
                position: position,
                priceVsCPR: parseFloat(priceVsCPR.toFixed(2)),
                range: parseFloat(range.toFixed(4))
            };
        }
        
        // Calculate Support Convergence with CPR
        function calculateSupportConvergence(supportLevels, flippedLevels, cprData) {
            const allSupports = [...supportLevels, ...flippedLevels];
            const cprLevels = [
                { price: cprData.tc, type: 'TC' },
                { price: cprData.cp, type: 'CP' },
                { price: cprData.bc, type: 'BC' }
            ];
            
            let closestConvergence = null;
            let minDifference = Infinity;
            let convergenceType = '';
            let convergenceCPRType = '';
            let convergencePrice = 0;
            let convergenceSupportPrice = 0;
            
            // Check each support level against each CPR level
            for (const support of allSupports) {
                for (const cprLevel of cprLevels) {
                    if (cprLevel.price <= 0) continue; // Skip invalid CPR levels
                    
                    const difference = Math.abs(support.price - cprLevel.price);
                    const percentDifference = (difference / cprLevel.price) * 100;
                    
                    // Check if within 0.5% or overlapping
                    if (percentDifference <= 0.5) {
                        if (difference < minDifference) {
                            minDifference = difference;
                            closestConvergence = support;
                            convergenceType = support.type;
                            convergenceCPRType = cprLevel.type;
                            convergenceSupportPrice = support.price;
                            
                            // Calculate the middle point if they're close but not exactly the same
                            if (difference > 0) {
                                convergencePrice = (support.price + cprLevel.price) / 2;
                            } else {
                                convergencePrice = support.price; // Exact overlap
                            }
                        }
                    }
                }
            }
            
            if (closestConvergence) {
                return {
                    status: 'Solid Support',
                    price: parseFloat(convergencePrice.toFixed(4)),
                    supportType: convergenceType,
                    cprType: convergenceCPRType,
                    differencePercent: parseFloat((minDifference / convergencePrice * 100).toFixed(2)),
                    supportPrice: parseFloat(convergenceSupportPrice.toFixed(4))
                };
            } else {
                return {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                };
            }
        }
        
        // NEW: Calculate Resistance Convergence with CPR
        function calculateResistanceConvergence(resistanceLevels, flippedResistanceLevels, cprData) {
            const allResistances = [...resistanceLevels, ...flippedResistanceLevels];
            const cprLevels = [
                { price: cprData.tc, type: 'TC' },
                { price: cprData.cp, type: 'CP' },
                { price: cprData.bc, type: 'BC' }
            ];
            
            let closestConvergence = null;
            let minDifference = Infinity;
            let convergenceType = '';
            let convergenceCPRType = '';
            let convergencePrice = 0;
            let convergenceResistancePrice = 0;
            
            // Check each resistance level against each CPR level
            for (const resistance of allResistances) {
                for (const cprLevel of cprLevels) {
                    if (cprLevel.price <= 0) continue; // Skip invalid CPR levels
                    
                    const difference = Math.abs(resistance.price - cprLevel.price);
                    const percentDifference = (difference / cprLevel.price) * 100;
                    
                    // Check if within 0.5% or overlapping
                    if (percentDifference <= 0.5) {
                        if (difference < minDifference) {
                            minDifference = difference;
                            closestConvergence = resistance;
                            convergenceType = resistance.type;
                            convergenceCPRType = cprLevel.type;
                            convergenceResistancePrice = resistance.price;
                            
                            // Calculate the middle point if they're close but not exactly the same
                            if (difference > 0) {
                                convergencePrice = (resistance.price + cprLevel.price) / 2;
                            } else {
                                convergencePrice = resistance.price; // Exact overlap
                            }
                        }
                    }
                }
            }
            
            if (closestConvergence) {
                return {
                    status: 'Solid Resistance',
                    price: parseFloat(convergencePrice.toFixed(4)),
                    resistanceType: convergenceType,
                    cprType: convergenceCPRType,
                    differencePercent: parseFloat((minDifference / convergencePrice * 100).toFixed(2)),
                    resistancePrice: parseFloat(convergenceResistancePrice.toFixed(4))
                };
            } else {
                return {
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                };
            }
        }
        
        // Calculate VWAP with bands (Session anchor, Source: (H+L+C)/3, Bands: Standard Deviation, Std Dev: 1)
        function calculateVWAP(klines, currentPrice) {
            if (!klines || klines.length < 20) {
                return {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'insufficient data',
                    standardDeviation: 0
                };
            }
            
            // Get today's UTC date for session anchor (daily session)
            const now = new Date();
            const startOfDay = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0);
            
            // Filter candles for current session (today)
            let sessionCandles = klines.filter(k => k.time >= startOfDay);
            
            if (sessionCandles.length < 5) {
                // If not enough data for today, use last 24 hours as session
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                sessionCandles = klines.filter(k => k.time >= twentyFourHoursAgo);
            }
            
            if (sessionCandles.length < 5) {
                // Still not enough data, use all available candles
                sessionCandles = klines.slice(-50);
            }
            
            // Calculate cumulative VWAP
            let cumulativeTPV = 0; // Cumulative Typical Price * Volume
            let cumulativeVolume = 0;
            const typicalPrices = [];
            
            for (const candle of sessionCandles) {
                // Source: (High + Low + Close) / 3
                const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                typicalPrices.push(typicalPrice);
                
                cumulativeTPV += typicalPrice * candle.volume;
                cumulativeVolume += candle.volume;
            }
            
            if (cumulativeVolume === 0) {
                return {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'insufficient data',
                    standardDeviation: 0
                };
            }
            
            const vwap = cumulativeTPV / cumulativeVolume;
            
            // Calculate standard deviation of typical prices from VWAP
            let sumSquaredDifferences = 0;
            for (const tp of typicalPrices) {
                sumSquaredDifferences += Math.pow(tp - vwap, 2);
            }
            
            const standardDeviation = Math.sqrt(sumSquaredDifferences / typicalPrices.length);
            
            // Calculate bands (1 standard deviation)
            const upperBand = vwap + (1 * standardDeviation);
            const lowerBand = vwap - (1 * standardDeviation);
            
            // Calculate percentage distances with correct sign
            // Price ABOVE VWAP/UPPER/LOWER = Positive percentage
            // Price BELOW VWAP/UPPER/LOWER = Negative percentage
            const distanceFromVWAP = ((currentPrice - vwap) / vwap) * 100;
            const distanceFromUpperBand = ((currentPrice - upperBand) / upperBand) * 100;
            const distanceFromLowerBand = ((currentPrice - lowerBand) / lowerBand) * 100;
            
            // Determine position relative to VWAP
            let position = 'near';
            if (currentPrice > upperBand) {
                position = 'above';
            } else if (currentPrice < lowerBand) {
                position = 'below';
            } else if (Math.abs(distanceFromVWAP) > 0.5) {
                position = currentPrice > vwap ? 'above' : 'below';
            } else {
                position = 'near';
            }
            
            return {
                vwap: parseFloat(vwap.toFixed(6)),
                upperBand: parseFloat(upperBand.toFixed(6)),
                lowerBand: parseFloat(lowerBand.toFixed(6)),
                distanceFromVWAP: parseFloat(distanceFromVWAP.toFixed(2)),
                distanceFromUpperBand: parseFloat(distanceFromUpperBand.toFixed(2)),
                distanceFromLowerBand: parseFloat(distanceFromLowerBand.toFixed(2)),
                position: position,
                standardDeviation: parseFloat(standardDeviation.toFixed(6)),
                candlesUsed: sessionCandles.length
            };
        }
        
        // Calculate Indicator Summary
        function calculateIndicatorSummary(data, currentPrice) {
            const summary = {
                macd: {
                    status: data.macdAnalysis?.status || 'neutral',
                    histogram: data.macdAnalysis?.histogram || 0
                },
                crossover: {
                    type: data.macdAnalysis?.crossover || 'none',
                    strength: data.macdAnalysis?.crossoverStrength || 0,
                    periodsAgo: data.macdAnalysis?.crossoverPeriodsAgo || 0
                },
                volumeSpike: {
                    spike: data.volumeSpike?.spike || false,
                    multiple: data.volumeSpike?.multiple || 0
                },
                atr: {
                    volatility: data.atrAnalysis?.volatility || 'low',
                    atrPercentage: data.atrAnalysis?.atrPercentage || 0
                },
                obv: {
                    trend: data.obvAnalysis?.trend || 'neutral',
                    obvChange: data.obvAnalysis?.obvChange || 0
                },
                ichimoku: {
                    cloudPosition: data.ichimokuAnalysis?.cloudPosition || 'inside',
                    priceVsCloud: data.ichimokuAnalysis?.priceVsCloud || 0
                },
                ema: {
                    position: data.emaAnalysis?.position || 'cross',
                    differencePercentage: data.emaAnalysis?.differencePercentage || 0
                },
                supportLevels: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.supportLevels && data.supportLevels.length > 0) ? true : false
                },
                flippedSupport: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.flippedLevels && data.flippedLevels.length > 0) ? true : false
                },
                resistanceLevels: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.resistanceLevels && data.resistanceLevels.length > 0) ? true : false
                },
                flippedResistance: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.flippedResistanceLevels && data.flippedResistanceLevels.length > 0) ? true : false
                },
                cpr: {
                    tcPercentage: 0,
                    cpPercentage: 0,
                    bcPercentage: 0,
                    position: data.cprAnalysis?.position || 'inside'
                },
                vwap: {
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: data.vwapAnalysis?.position || 'near'
                },
                correlation: {
                    strength: data.correlationWithBTC?.strength || 'unknown',
                    percentage: data.correlationWithBTC?.percentage || 0,
                    independence: data.correlationWithBTC?.independence || 0
                },
                supportConvergence: {
                    status: data.supportConvergence?.status || 'No Convergence'
                },
                resistanceConvergence: {
                    status: data.resistanceConvergence?.status || 'No Convergence' // NEW
                },
                liquidityGrabSupport: {
                    detected: data.liquidityGrabSupport?.detected || false
                },
                liquidityGrabResistance: {
                    detected: data.liquidityGrabResistance?.detected || false
                }
            };
            
            // Calculate support level percentages
            if (summary.supportLevels.hasLevels && data.supportLevels.length > 0) {
                const closestSupport = data.supportLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.supportLevels[0].price, distance: Math.abs(data.supportLevels[0].price - currentPrice) });
                
                summary.supportLevels.closestDistance = closestSupport.distance;
                summary.supportLevels.percentage = parseFloat(((closestSupport.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate flipped support percentages
            if (summary.flippedSupport.hasLevels && data.flippedLevels.length > 0) {
                const closestFlipped = data.flippedLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.flippedLevels[0].price, distance: Math.abs(data.flippedLevels[0].price - currentPrice) });
                
                summary.flippedSupport.closestDistance = closestFlipped.distance;
                summary.flippedSupport.percentage = parseFloat(((closestFlipped.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate resistance level percentages
            if (summary.resistanceLevels.hasLevels && data.resistanceLevels.length > 0) {
                const closestResistance = data.resistanceLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.resistanceLevels[0].price, distance: Math.abs(data.resistanceLevels[0].price - currentPrice) });
                
                summary.resistanceLevels.closestDistance = closestResistance.distance;
                summary.resistanceLevels.percentage = parseFloat(((closestResistance.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate flipped resistance percentages
            if (summary.flippedResistance.hasLevels && data.flippedResistanceLevels.length > 0) {
                const closestFlippedResistance = data.flippedResistanceLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.flippedResistanceLevels[0].price, distance: Math.abs(data.flippedResistanceLevels[0].price - currentPrice) });
                
                summary.flippedResistance.closestDistance = closestFlippedResistance.distance;
                summary.flippedResistance.percentage = parseFloat(((closestFlippedResistance.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate CPR percentages
            if (data.cprAnalysis && data.cprAnalysis.tc > 0) {
                summary.cpr.tcPercentage = parseFloat(((data.cprAnalysis.tc - currentPrice) / currentPrice * 100).toFixed(2));
                summary.cpr.cpPercentage = parseFloat(((data.cprAnalysis.cp - currentPrice) / currentPrice * 100).toFixed(2));
                summary.cpr.bcPercentage = parseFloat(((data.cprAnalysis.bc - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate VWAP distances
            if (data.vwapAnalysis) {
                summary.vwap.distanceFromVWAP = data.vwapAnalysis.distanceFromVWAP || 0;
                summary.vwap.distanceFromUpperBand = data.vwapAnalysis.distanceFromUpperBand || 0;
                summary.vwap.distanceFromLowerBand = data.vwapAnalysis.distanceFromLowerBand || 0;
                summary.vwap.position = data.vwapAnalysis.position || 'near';
            }
            
            return summary;
        }
        
        // Setup WebSocket connections for real-time price updates
        function setupWebSocketConnections() {
            SYMBOLS.forEach(symbol => {
                setupWebSocketForSymbol(symbol);
            });
        }
        
        function setupWebSocketForSymbol(symbol) {
            if (wsConnections[symbol]) {
                try {
                    wsConnections[symbol].close();
                } catch (e) {
                    console.log(`Error closing existing WebSocket for ${symbol}:`, e);
                }
            }
            
            const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker`);
            
            ws.onopen = () => {
                console.log(`WebSocket connected for ${symbol}`);
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const currentPrice = parseFloat(data.c);
                    const symbol = data.s;
                    
                    if (cryptoData[symbol]) {
                        const previousPrice = cryptoData[symbol].currentPrice;
                        const change = currentPrice - previousPrice;
                        
                        cryptoData[symbol].currentPrice = currentPrice;
                        cryptoData[symbol].priceChange = change;
                        
                        // Recalculate VWAP with new price
                        if (cryptoData[symbol].indicatorKlines) {
                            cryptoData[symbol].vwapAnalysis = calculateVWAP(cryptoData[symbol].indicatorKlines, currentPrice);
                        }
                        
                        // Recalculate indicator summary with new price
                        cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(cryptoData[symbol], currentPrice);
                        
                        const now = Date.now();
                        if (!lastUpdateTimes[symbol] || now - lastUpdateTimes[symbol] >= WS_UPDATE_THROTTLE) {
                            updatePriceCell(symbol, currentPrice, change);
                            updateVWAPCell(symbol, cryptoData[symbol].vwapAnalysis, currentPrice);
                            updateIndicatorSummary1Cell(symbol, cryptoData[symbol].indicatorSummary);
                            updateIndicatorSummary2Cell(symbol, cryptoData[symbol].indicatorSummary);
                            updateIndicatorSummary3Cell(symbol, cryptoData[symbol].indicatorSummary);
                            lastUpdateTimes[symbol] = now;
                        }
                        
                        lastPrices[symbol] = currentPrice;
                    }
                } catch (error) {
                    console.error(`Error processing WebSocket message for ${symbol}:`, error);
                }
            };
            
            ws.onerror = (error) => {
                console.error(`WebSocket error for ${symbol}:`, error);
            };
            
            ws.onclose = () => {
                console.log(`WebSocket closed for ${symbol}, attempting to reconnect in 5 seconds...`);
                setTimeout(() => {
                    setupWebSocketForSymbol(symbol);
                }, 5000);
            };
            
            wsConnections[symbol] = ws;
        }
        
        // Close all WebSocket connections
        function closeAllWebSocketConnections() {
            SYMBOLS.forEach(symbol => {
                if (wsConnections[symbol]) {
                    try {
                        wsConnections[symbol].close();
                    } catch (e) {
                        console.log(`Error closing WebSocket for ${symbol}:`, e);
                    }
                    delete wsConnections[symbol];
                }
            });
        }
        
        // Show TradingView modal
        function showTradingViewModal(symbol) {
            currentSymbolForLink = symbol;
            tradingviewModal.style.display = 'flex';
        }
        
        // Hide TradingView modal
        function hideTradingViewModal() {
            tradingviewModal.style.display = 'none';
            currentSymbolForLink = null;
        }
        
        // NEW: Show Binance modal
        function showBinanceModal(symbol) {
            currentSymbolForLink = symbol;
            binanceModal.style.display = 'flex';
        }
        
        // NEW: Hide Binance modal
        function hideBinanceModal() {
            binanceModal.style.display = 'none';
            currentSymbolForLink = null;
        }
        
        // Generate TradingView deep link for mobile app
        function getTradingViewAppLink(symbol) {
            const tvSymbol = `BINANCE:${symbol}`;
            return `tradingview://chart/?symbol=${tvSymbol}&interval=60`;
        }
        
        // Generate TradingView web link
        function getTradingViewWebLink(symbol) {
            const tvSymbol = `BINANCE:${symbol}`;
            return `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=60`;
        }
        
        // NEW: Generate Binance app deep link for spot trading
        function getBinanceAppLink(symbol) {
            // Binance app deep link for spot trading
            return `binance://spot/${symbol}`;
        }
        
        // NEW: Generate Binance web link for spot trading
        function getBinanceWebLink(symbol) {
            // Format symbol for Binance web URL (BTCUSDT -> BTC_USDT)
            const formattedSymbol = symbol.replace('USDT', '_USDT');
            return `https://www.binance.com/en/trade/${formattedSymbol}?type=spot`;
        }
        
        // Open TradingView app with improved method
        function openTradingViewApp(symbol) {
            const appLink = getTradingViewAppLink(symbol);
            const webLink = getTradingViewWebLink(symbol);
            
            window.location.href = appLink;
            
            setTimeout(function() {
                window.open(webLink, '_blank');
            }, 500);
            
            setTimeout(function() {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = appLink;
                document.body.appendChild(iframe);
                
                setTimeout(function() {
                    document.body.removeChild(iframe);
                }, 1000);
            }, 100);
        }
        
        // Open TradingView web
        function openTradingViewWeb(symbol) {
            const webLink = getTradingViewWebLink(symbol);
            window.open(webLink, '_blank');
        }
        
        // NEW: Open Binance app for spot trading
        function openBinanceApp(symbol) {
            const appLink = getBinanceAppLink(symbol);
            const webLink = getBinanceWebLink(symbol);
            
            window.location.href = appLink;
            
            setTimeout(function() {
                window.open(webLink, '_blank');
            }, 500);
            
            setTimeout(function() {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = appLink;
                document.body.appendChild(iframe);
                
                setTimeout(function() {
                    document.body.removeChild(iframe);
                }, 1000);
            }, 100);
        }
        
        // NEW: Open Binance web for spot trading
        function openBinanceWeb(symbol) {
            const webLink = getBinanceWebLink(symbol);
            window.open(webLink, '_blank');
        }
        
        // Handle TradingView link click
        function handleTradingViewClick(symbol, event) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                event.preventDefault();
                showTradingViewModal(symbol);
                return false;
            } else {
                openTradingViewWeb(symbol);
                event.preventDefault();
                return false;
            }
        }
        
        // NEW: Handle Binance link click
        function handleBinanceClick(symbol, event) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                event.preventDefault();
                showBinanceModal(symbol);
                return false;
            } else {
                openBinanceWeb(symbol);
                event.preventDefault();
                return false;
            }
        }
        
        // Update the last updated time display
        function updateTimeDisplay() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            lastUpdatedTime.textContent = timeString;
        }
        
        // Fetch all historical data (klines) for indicators
        async function fetchAllHistoricalData() {
            if (isUpdating) return;
            
            isUpdating = true;
            clearError();
            
            try {
                const promises = SYMBOLS.map(symbol => fetchHistoricalData(symbol));
                const results = await Promise.allSettled(promises);
                
                const failed = results.filter(r => r.status === 'rejected');
                if (failed.length > 0) {
                    console.error('Some historical data requests failed:', failed);
                    if (failed.length === SYMBOLS.length) {
                        throw new Error('Unable to fetch historical data from Binance API');
                    }
                }
                
                // For correlation, we need 1-hour BTC prices in both modes
                if (cryptoData['BTCUSDT'] && cryptoData['BTCUSDT'].correlationKlines) {
                    btcHourlyPrices = cryptoData['BTCUSDT'].correlationKlines
                        .slice(-CORRELATION_PERIOD)
                        .map(k => k.close);
                }
                
                calculateAllCorrelations();
                
                updateTable();
                applyFilters(); // Apply filters after data is loaded
            } catch (error) {
                console.error('Error fetching historical data:', error);
                showError(`Connection error: ${error.message}. Trying again...`);
            } finally {
                isUpdating = false;
            }
        }
        
        // Calculate correlations for all symbols with BTC
        function calculateAllCorrelations() {
            if (btcHourlyPrices.length < 10) {
                return;
            }
            
            Object.keys(cryptoData).forEach(symbol => {
                if (symbol === 'BTCUSDT') {
                    cryptoData[symbol].correlationWithBTC = {
                        correlation: 1.0,
                        percentage: 100,
                        strength: 'high',
                        independence: 0,
                        trend: 'perfect'
                    };
                    return;
                }
                
                const data = cryptoData[symbol];
                if (data && data.correlationKlines && data.correlationKlines.length >= 10) {
                    const correlation = calculateCorrelationWithBTC(data.correlationKlines);
                    cryptoData[symbol].correlationWithBTC = correlation;
                } else {
                    cryptoData[symbol].correlationWithBTC = {
                        correlation: 0,
                        percentage: 0,
                        strength: 'unknown',
                        independence: 100,
                        trend: 'unknown'
                    };
                }
                
                // Calculate indicator summary
                if (data && data.currentPrice) {
                    cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(data, data.currentPrice);
                }
            });
        }
        
        // Calculate correlation with BTC
        function calculateCorrelationWithBTC(correlationKlines) {
            if (correlationKlines.length < 10 || btcHourlyPrices.length < 10) {
                return {
                    correlation: 0,
                    percentage: 0,
                    strength: 'insufficient data',
                    independence: 100,
                    trend: 'unknown'
                };
            }
            
            const coinPrices = correlationKlines
                .slice(-CORRELATION_PERIOD)
                .map(k => k.close);
            
            const minLength = Math.min(coinPrices.length, btcHourlyPrices.length);
            const coinSlice = coinPrices.slice(-minLength);
            const btcSlice = btcHourlyPrices.slice(-minLength);
            
            if (minLength < 10) {
                return {
                    correlation: 0,
                    percentage: 0,
                    strength: 'insufficient data',
                    independence: 100,
                    trend: 'unknown'
                };
            }
            
            const correlation = calculatePearsonCorrelation(coinSlice, btcSlice);
            const percentage = Math.abs(correlation * 100);
            
            let strength = 'low';
            if (percentage >= 70) {
                strength = 'high';
            } else if (percentage >= 30) {
                strength = 'medium';
            } else {
                strength = 'low';
            }
            
            const independence = 100 - percentage;
            
            let trend = 'neutral';
            if (correlation > 0.5) {
                trend = 'positive';
            } else if (correlation < -0.5) {
                trend = 'negative';
            } else if (correlation > 0) {
                trend = 'weakly positive';
            } else if (correlation < 0) {
                trend = 'weakly negative';
            } else {
                trend = 'no correlation';
            }
            
            return {
                correlation: parseFloat(correlation.toFixed(3)),
                percentage: parseFloat(percentage.toFixed(1)),
                strength: strength,
                independence: parseFloat(independence.toFixed(1)),
                trend: trend
            };
        }
        
        // Calculate Pearson correlation coefficient
        function calculatePearsonCorrelation(x, y) {
            const n = x.length;
            
            const meanX = x.reduce((a, b) => a + b, 0) / n;
            const meanY = y.reduce((a, b) => a + b, 0) / n;
            
            let numerator = 0;
            let denomX = 0;
            let denomY = 0;
            
            for (let i = 0; i < n; i++) {
                const diffX = x[i] - meanX;
                const diffY = y[i] - meanY;
                
                numerator += diffX * diffY;
                denomX += diffX * diffX;
                denomY += diffY * diffY;
            }
            
            if (denomX === 0 || denomY === 0) {
                return 0;
            }
            
            const correlation = numerator / Math.sqrt(denomX * denomY);
            
            return Math.max(-1, Math.min(1, correlation));
        }
        
        // Fetch historical data for a specific cryptocurrency with timeframe mode support
        async function fetchHistoricalData(symbol) {
            try {
                // Get initial price from ticker API
                const priceResponse = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                if (!priceResponse.ok) throw new Error(`Failed to fetch price for ${symbol}`);
                const priceData = await priceResponse.json();
                
                const currentPrice = parseFloat(priceData.price);
                
                // Determine intervals based on current timeframe
                let indicatorInterval, correlationInterval;
                
                if (currentTimeframe === '1h') {
                    // 1-hour mode
                    indicatorInterval = '1h'; // Most indicators use 1h
                    correlationInterval = '1h'; // Correlation uses 1h
                } else {
                    // 4-hour mode
                    indicatorInterval = '4h'; // Most indicators use 4h
                    correlationInterval = '1h'; // Correlation still uses 1h
                }
                
                // Get indicator kline data (for most technical indicators)
                const indicatorKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${indicatorInterval}&limit=${MACD_CANDLE_LIMIT}`);
                if (!indicatorKlineResponse.ok) throw new Error(`Failed to fetch ${indicatorInterval} kline data for ${symbol}`);
                const indicatorKlineData = await indicatorKlineResponse.json();
                
                // Get correlation kline data (1-hour for correlation with BTC)
                const correlationKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=${CORRELATION_PERIOD + 10}`);
                if (!correlationKlineResponse.ok) throw new Error(`Failed to fetch 1h correlation kline data for ${symbol}`);
                const correlationKlineData = await correlationKlineResponse.json();
                
                // Get daily kline data for CPR calculation
                const dailyKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1d&limit=5`);
                if (!dailyKlineResponse.ok) throw new Error(`Failed to fetch daily kline data for ${symbol}`);
                const dailyKlineData = await dailyKlineResponse.json();
                
                // Process indicator candles
                const indicatorKlines = indicatorKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Process correlation candles (1-hour)
                const correlationKlines = correlationKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Process daily candles for CPR calculation
                const dailyKlines = dailyKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Calculate MACD status with crossover detection (using indicatorKlines)
                const macdAnalysis = calculateMACDWithCrossover(indicatorKlines);
                
                // Calculate volume spike (using indicatorKlines)
                const volumeSpike = calculateVolumeSpike(indicatorKlines);
                
                // Calculate ATR volatility (using indicatorKlines)
                const atrAnalysis = calculateATRVolatility(indicatorKlines, currentPrice);
                
                // Calculate OBV (On Balance Volume) trend (using indicatorKlines)
                const obvAnalysis = calculateOBVTrend(indicatorKlines);
                
                // Calculate Ichimoku Cloud position (using indicatorKlines)
                const ichimokuAnalysis = calculateIchimokuCloud(indicatorKlines, currentPrice);
                
                // Calculate EMA analysis with current period (using indicatorKlines)
                const emaAnalysis = calculateEMAAnalysis(indicatorKlines, currentPrice, currentEMAPeriod);
                
                // Calculate support levels, flipped support, resistance levels, and flipped resistance (using indicatorKlines)
                const marketStructure = calculateMarketStructure(indicatorKlines, currentPrice);
                
                // Calculate Liquidity Grab (Support)
                const liquidityGrabSupport = calculateLiquidityGrabSupport(marketStructure.supportLevels, indicatorKlines, currentPrice);
                
                // Calculate Liquidity Grab (Resistance)
                const liquidityGrabResistance = calculateLiquidityGrabResistance(marketStructure.resistanceLevels, indicatorKlines, currentPrice);
                
                // Calculate Daily CPR (Central Pivot Range)
                const cprAnalysis = calculateDailyCPR(dailyKlines, currentPrice);
                
                // Calculate Support Convergence with CPR
                const supportConvergence = calculateSupportConvergence(
                    marketStructure.supportLevels, 
                    marketStructure.flippedLevels, 
                    cprAnalysis
                );
                
                // NEW: Calculate Resistance Convergence with CPR
                const resistanceConvergence = calculateResistanceConvergence(
                    marketStructure.resistanceLevels,
                    marketStructure.flippedResistanceLevels,
                    cprAnalysis
                );
                
                // Calculate VWAP (Volume Weighted Average Price)
                const vwapAnalysis = calculateVWAP(indicatorKlines, currentPrice);
                
                // Calculate Indicator Summary
                const indicatorSummary = calculateIndicatorSummary({
                    macdAnalysis,
                    volumeSpike,
                    atrAnalysis,
                    obvAnalysis,
                    ichimokuAnalysis,
                    emaAnalysis,
                    supportLevels: marketStructure.supportLevels,
                    flippedLevels: marketStructure.flippedLevels,
                    resistanceLevels: marketStructure.resistanceLevels,
                    flippedResistanceLevels: marketStructure.flippedResistanceLevels,
                    cprAnalysis,
                    vwapAnalysis,
                    supportConvergence,
                    resistanceConvergence, // NEW
                    liquidityGrabSupport,
                    liquidityGrabResistance
                }, currentPrice);
                
                // Store data
                cryptoData[symbol] = {
                    symbol: symbol,
                    currentPrice: currentPrice,
                    macdAnalysis: macdAnalysis,
                    volumeSpike: volumeSpike,
                    atrAnalysis: atrAnalysis,
                    obvAnalysis: obvAnalysis,
                    ichimokuAnalysis: ichimokuAnalysis,
                    emaAnalysis: emaAnalysis,
                    cprAnalysis: cprAnalysis,
                    supportConvergence: supportConvergence,
                    resistanceConvergence: resistanceConvergence, // NEW
                    supportLevels: marketStructure.supportLevels,
                    flippedLevels: marketStructure.flippedLevels,
                    resistanceLevels: marketStructure.resistanceLevels,
                    flippedResistanceLevels: marketStructure.flippedResistanceLevels,
                    liquidityGrabSupport: liquidityGrabSupport,
                    liquidityGrabResistance: liquidityGrabResistance,
                    vwapAnalysis: vwapAnalysis,
                    indicatorSummary: indicatorSummary,
                    indicatorKlines: indicatorKlines,
                    correlationKlines: correlationKlines,
                    dailyKlines: dailyKlines,
                    lastUpdate: new Date()
                };
                
                // Determine if price went up or down for animation
                if (lastPrices[symbol]) {
                    const change = currentPrice - lastPrices[symbol];
                    cryptoData[symbol].priceChange = change;
                }
                
                lastPrices[symbol] = currentPrice;
                
                // Setup WebSocket if not already connected
                if (!wsConnections[symbol]) {
                    setupWebSocketForSymbol(symbol);
                }
                
            } catch (error) {
                console.error(`Error fetching historical data for ${symbol}:`, error);
                if (!cryptoData[symbol]) {
                    cryptoData[symbol] = createErrorData(symbol);
                }
            }
        }
        
        // Create error data structure
        function createErrorData(symbol) {
            return {
                symbol: symbol,
                currentPrice: 0,
                macdAnalysis: {
                    status: 'error',
                    macdLine: 0,
                    signalLine: 0,
                    histogram: 0,
                    crossover: 'none',
                    crossoverStrength: 0,
                    crossoverPeriodsAgo: 0
                },
                volumeSpike: {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                },
                atrAnalysis: {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'error',
                    trueRange: 0,
                    priceChange24h: 0
                },
                obvAnalysis: {
                    trend: 'error',
                    obvValue: 0,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                },
                ichimokuAnalysis: {
                    cloudPosition: 'error',
                    conversionLine: 0,
                    baseLine: 0,
                    leadingSpanA: 0,
                    leadingSpanB: 0,
                    cloudTop: 0,
                    cloudBottom: 0,
                    priceVsCloud: 0
                },
                emaAnalysis: {
                    position: 'error',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                },
                cprAnalysis: {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'error',
                    priceVsCPR: 0,
                    range: 0
                },
                supportConvergence: {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                },
                resistanceConvergence: { // NEW
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                },
                liquidityGrabSupport: {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Error calculating liquidity grab support'
                },
                liquidityGrabResistance: {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Error calculating liquidity grab resistance'
                },
                vwapAnalysis: {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'error',
                    standardDeviation: 0,
                    candlesUsed: 0
                },
                indicatorSummary: {
                    macd: { status: 'error', histogram: 0 },
                    crossover: { type: 'none', strength: 0, periodsAgo: 0 },
                    volumeSpike: { spike: false, multiple: 0 },
                    atr: { volatility: 'error', atrPercentage: 0 },
                    obv: { trend: 'error', obvChange: 0 },
                    ichimoku: { cloudPosition: 'error', priceVsCloud: 0 },
                    ema: { position: 'error', differencePercentage: 0 },
                    supportLevels: { closestDistance: 0, percentage: 0, hasLevels: false },
                    flippedSupport: { closestDistance: 0, percentage: 0, hasLevels: false },
                    resistanceLevels: { closestDistance: 0, percentage: 0, hasLevels: false },
                    flippedResistance: { closestDistance: 0, percentage: 0, hasLevels: false },
                    cpr: { tcPercentage: 0, cpPercentage: 0, bcPercentage: 0, position: 'error' },
                    vwap: { distanceFromVWAP: 0, distanceFromUpperBand: 0, distanceFromLowerBand: 0, position: 'error' },
                    correlation: { strength: 'error', percentage: 0, independence: 0 },
                    supportConvergence: { status: 'No Convergence' },
                    resistanceConvergence: { status: 'No Convergence' }, // NEW
                    liquidityGrabSupport: { detected: false },
                    liquidityGrabResistance: { detected: false }
                },
                supportLevels: [],
                flippedLevels: [],
                resistanceLevels: [],
                flippedResistanceLevels: [],
                correlationWithBTC: {
                    correlation: 0,
                    percentage: 0,
                    strength: 'error',
                    independence: 0,
                    trend: 'unknown'
                },
                lastUpdate: new Date()
            };
        }
        
        // Calculate EMA analysis
        function calculateEMAAnalysis(klines, currentPrice, period) {
            if (klines.length < period + 5) {
                return {
                    position: 'insufficient data',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                };
            }
            
            const closingPrices = klines.map(k => k.close);
            const emaValues = calculateEMA(closingPrices, period);
            const latestEMA = emaValues[emaValues.length - 1];
            
            if (latestEMA === null) {
                return {
                    position: 'error',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                };
            }
            
            const difference = currentPrice - latestEMA;
            const differencePercentage = (difference / latestEMA) * 100;
            
            let position = 'cross';
            let trend = 'neutral';
            
            if (differencePercentage > 0.5) {
                position = 'above';
                trend = 'bullish';
            } else if (differencePercentage < -0.5) {
                position = 'below';
                trend = 'bearish';
            } else {
                position = 'cross';
                trend = 'neutral';
            }
            
            const previousEMA = emaValues[emaValues.length - 2];
            let emaTrend = 'neutral';
            
            if (previousEMA !== null) {
                if (latestEMA > previousEMA) {
                    emaTrend = 'rising';
                } else if (latestEMA < previousEMA) {
                    emaTrend = 'falling';
                }
            }
            
            return {
                position: position,
                emaValue: parseFloat(latestEMA.toFixed(4)),
                difference: parseFloat(difference.toFixed(4)),
                differencePercentage: parseFloat(differencePercentage.toFixed(2)),
                trend: emaTrend
            };
        }
        
        // Calculate MACD with crossover detection from candles
        function calculateMACDWithCrossover(klines) {
            if (klines.length < 40) {
                return {
                    status: 'insufficient data',
                    macdLine: 0,
                    signalLine: 0,
                    histogram: 0,
                    crossover: 'none',
                    crossoverStrength: 0,
                    crossoverPeriodsAgo: 0
                };
            }
            
            const closingPrices = klines.map(k => k.close);
            
            const ema12 = calculateEMA(closingPrices, 12);
            const ema26 = calculateEMA(closingPrices, 26);
            
            const macdLine = [];
            for (let i = 0; i < ema12.length; i++) {
                if (ema12[i] !== null && ema26[i] !== null) {
                    macdLine.push(ema12[i] - ema26[i]);
                } else {
                    macdLine.push(null);
                }
            }
            
            const validMACDLine = macdLine.filter(v => v !== null);
            const signalLine = calculateEMA(validMACDLine, 9);
            
            const latestMacdLine = macdLine[macdLine.length - 1];
            const latestSignalLine = signalLine[signalLine.length - 1];
            
            if (latestMacdLine !== null && latestSignalLine !== null) {
                const histogram = latestMacdLine - latestSignalLine;
                
                let status = 'neutral';
                
                if (latestMacdLine > latestSignalLine) {
                    status = 'positive';
                } else if (latestMacdLine < latestSignalLine) {
                    status = 'negative';
                } else {
                    status = 'neutral';
                }
                
                const crossover = detectMACDCrossover(macdLine, signalLine);
                
                return {
                    status: status,
                    macdLine: parseFloat(latestMacdLine.toFixed(6)),
                    signalLine: parseFloat(latestSignalLine.toFixed(6)),
                    histogram: parseFloat(histogram.toFixed(6)),
                    crossover: crossover.type,
                    crossoverStrength: crossover.strength,
                    crossoverPeriodsAgo: crossover.periodsAgo
                };
            }
            
            return {
                status: 'error',
                macdLine: 0,
                signalLine: 0,
                histogram: 0,
                crossover: 'none',
                crossoverStrength: 0,
                crossoverPeriodsAgo: 0
            };
        }
        
        // Detect MACD crossover in recent periods
        function detectMACDCrossover(macdLine, signalLine) {
            const validMacdIndices = [];
            const validSignalIndices = [];
            
            for (let i = macdLine.length - 1; i >= 0; i--) {
                if (macdLine[i] !== null) validMacdIndices.push(i);
                if (validMacdIndices.length >= 10) break;
            }
            
            for (let i = signalLine.length - 1; i >= 0; i--) {
                if (signalLine[i] !== null) validSignalIndices.push(i);
                if (validSignalIndices.length >= 10) break;
            }
            
            if (validMacdIndices.length < 3 || validSignalIndices.length < 3) {
                return { type: 'none', strength: 0, periodsAgo: 0 };
            }
            
            const recentMacdValues = [];
            const recentSignalValues = [];
            
            for (let i = 0; i < Math.min(5, validMacdIndices.length, validSignalIndices.length); i++) {
                const macdIdx = validMacdIndices[i];
                const signalIdx = validSignalIndices[i];
                
                if (macdLine[macdIdx] !== null && signalLine[signalIdx] !== null) {
                    recentMacdValues.push({ value: macdLine[macdIdx], index: macdIdx });
                    recentSignalValues.push({ value: signalLine[signalIdx], index: signalIdx });
                }
            }
            
            recentMacdValues.sort((a, b) => a.index - b.index);
            recentSignalValues.sort((a, b) => a.index - b.index);
            
            for (let i = Math.max(0, recentMacdValues.length - 3); i < recentMacdValues.length - 1; i++) {
                const currentMacd = recentMacdValues[i].value;
                const currentSignal = recentSignalValues[i].value;
                const nextMacd = recentMacdValues[i + 1].value;
                const nextSignal = recentSignalValues[i + 1].value;
                
                if (currentMacd <= currentSignal && nextMacd > nextSignal) {
                    const strength = Math.abs(nextMacd - nextSignal);
                    const periodsAgo = recentMacdValues.length - (i + 2);
                    return { type: 'bullish', strength: strength, periodsAgo: periodsAgo };
                }
                
                if (currentMacd >= currentSignal && nextMacd < nextSignal) {
                    const strength = Math.abs(nextMacd - nextSignal);
                    const periodsAgo = recentMacdValues.length - (i + 2);
                    return { type: 'bearish', strength: strength, periodsAgo: periodsAgo };
                }
            }
            
            return { type: 'none', strength: 0, periodsAgo: 0 };
        }
        
        // Calculate volume spike from candles
        function calculateVolumeSpike(klines) {
            if (klines.length < 21) {
                return {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                };
            }
            
            const closedCandles = klines.slice(-21, -1);
            
            if (closedCandles.length < 20) {
                return {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                };
            }
            
            const volumes = closedCandles.map(candle => candle.volume);
            const sum = volumes.reduce((a, b) => a + b, 0);
            const averageVolume = sum / volumes.length;
            
            const recentCandle = closedCandles[closedCandles.length - 1];
            const recentVolume = recentCandle.volume;
            
            const multiple = recentVolume / averageVolume;
            const spike = multiple >= 1.5;
            
            return {
                spike: spike,
                multiple: parseFloat(multiple.toFixed(1)),
                volume: recentVolume,
                averageVolume: averageVolume
            };
        }
        
        // Calculate ATR (Average True Range) volatility
        function calculateATRVolatility(klines, currentPrice) {
            if (klines.length < ATR_PERIOD + 5) {
                return {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'insufficient data',
                    trueRange: 0,
                    priceChange24h: 0
                };
            }
            
            const trueRanges = [];
            
            for (let i = 1; i < klines.length; i++) {
                const current = klines[i];
                const previous = klines[i-1];
                
                const highLow = current.high - current.low;
                const highPrevClose = Math.abs(current.high - previous.close);
                const lowPrevClose = Math.abs(current.low - previous.close);
                
                const trueRange = Math.max(highLow, highPrevClose, lowPrevClose);
                trueRanges.push(trueRange);
            }
            
            if (trueRanges.length < ATR_PERIOD) {
                return {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'insufficient data',
                    trueRange: 0,
                    priceChange24h: 0
                };
            }
            
            const recentTrueRanges = trueRanges.slice(-ATR_PERIOD);
            const atrValue = recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / ATR_PERIOD;
            
            const atrPercentage = (atrValue / currentPrice) * 100;
            
            const currentTrueRange = trueRanges[trueRanges.length - 1] || 0;
            
            // Calculate 24h price change based on the timeframe
            let priceChange24h = 0;
            if (klines.length >= 24) {
                const price24hAgo = klines[klines.length - 24].close;
                priceChange24h = ((currentPrice - price24hAgo) / price24hAgo) * 100;
            } else if (klines.length > 0) {
                const priceStart = klines[0].close;
                priceChange24h = ((currentPrice - priceStart) / priceStart) * 100;
            }
            
            let volatility = 'low';
            
            if (atrPercentage >= 3.0) {
                volatility = 'high';
            } else if (atrPercentage >= 1.5) {
                volatility = 'moderate';
            } else if (atrPercentage >= 0.5) {
                volatility = 'good';
            } else {
                volatility = 'low';
            }
            
            return {
                atrValue: parseFloat(atrValue.toFixed(6)),
                atrPercentage: parseFloat(atrPercentage.toFixed(2)),
                volatility: volatility,
                trueRange: parseFloat(currentTrueRange.toFixed(6)),
                priceChange24h: parseFloat(priceChange24h.toFixed(2))
            };
        }
        
        // Calculate OBV (On Balance Volume) trend
        function calculateOBVTrend(klines) {
            if (klines.length < 10) {
                return {
                    trend: 'insufficient data',
                    obvValue: 0,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                };
            }
            
            let obv = 0;
            const obvValues = [];
            
            for (let i = 0; i < klines.length; i++) {
                const current = klines[i];
                const volume = current.volume;
                
                if (i === 0) {
                    obv = 0;
                } else {
                    const previous = klines[i-1];
                    
                    if (current.close > previous.close) {
                        obv += volume;
                    } else if (current.close < previous.close) {
                        obv -= volume;
                    }
                }
                
                obvValues.push(obv);
            }
            
            const recentOBVValues = obvValues.slice(-OBV_PERIOD);
            
            if (recentOBVValues.length < 5) {
                return {
                    trend: 'insufficient data',
                    obvValue: obv,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                };
            }
            
            const currentOBV = recentOBVValues[recentOBVValues.length - 1];
            const previousOBV = recentOBVValues[0];
            
            const obvChange = previousOBV !== 0 ? ((currentOBV - previousOBV) / Math.abs(previousOBV)) * 100 : 0;
            
            let trend = 'neutral';
            let trendStrength = 0;
            
            const lastFiveOBV = recentOBVValues.slice(-5);
            
            let risingCount = 0;
            let fallingCount = 0;
            
            for (let i = 1; i < lastFiveOBV.length; i++) {
                if (lastFiveOBV[i] > lastFiveOBV[i-1]) {
                    risingCount++;
                } else if (lastFiveOBV[i] < lastFiveOBV[i-1]) {
                    fallingCount++;
                }
            }
            
            if (risingCount >= 3 && currentOBV > previousOBV) {
                trend = 'rising';
                trendStrength = Math.abs(obvChange);
            } else if (fallingCount >= 3 && currentOBV < previousOBV) {
                trend = 'falling';
                trendStrength = Math.abs(obvChange);
            } else {
                trend = 'neutral';
                trendStrength = 0;
            }
            
            const recentPrices = klines.slice(-OBV_PERIOD).map(k => k.close);
            const priceChange = ((recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices[0]) * 100;
            
            const volumeConfirmation = 
                (trend === 'rising' && priceChange > 0) || 
                (trend === 'falling' && priceChange < 0) ||
                (trend === 'neutral' && Math.abs(priceChange) < 0.5);
            
            return {
                trend: trend,
                obvValue: parseFloat(currentOBV.toFixed(2)),
                obvChange: parseFloat(obvChange.toFixed(2)),
                trendStrength: parseFloat(trendStrength.toFixed(2)),
                volumeConfirmation: volumeConfirmation
            };
        }
        
        // Calculate Ichimoku Cloud position
        function calculateIchimokuCloud(klines, currentPrice) {
            if (klines.length < 52) {
                return {
                    cloudPosition: 'insufficient data',
                    conversionLine: 0,
                    baseLine: 0,
                    leadingSpanA: 0,
                    leadingSpanB: 0,
                    cloudTop: 0,
                    cloudBottom: 0,
                    priceVsCloud: 0
                };
            }
            
            const tenkanPeriod = 9;
            let tenkanHigh = 0;
            let tenkanLow = Number.MAX_VALUE;
            
            for (let i = klines.length - tenkanPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    tenkanHigh = Math.max(tenkanHigh, klines[i].high);
                    tenkanLow = Math.min(tenkanLow, klines[i].low);
                }
            }
            
            const conversionLine = (tenkanHigh + tenkanLow) / 2;
            
            const kijunPeriod = 26;
            let kijunHigh = 0;
            let kijunLow = Number.MAX_VALUE;
            
            for (let i = klines.length - kijunPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    kijunHigh = Math.max(kijunHigh, klines[i].high);
                    kijunLow = Math.min(kijunLow, klines[i].low);
                }
            }
            
            const baseLine = (kijunHigh + kijunLow) / 2;
            
            const leadingSpanA = (conversionLine + baseLine) / 2;
            
            const senkouBPeriod = 52;
            let senkouBHigh = 0;
            let senkouBLow = Number.MAX_VALUE;
            
            for (let i = klines.length - senkouBPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    senkouBHigh = Math.max(senkouBHigh, klines[i].high);
                    senkouBLow = Math.min(senkouBLow, klines[i].low);
                }
            }
            
            const leadingSpanB = (senkouBHigh + senkouBLow) / 2;
            
            const cloudTop = Math.max(leadingSpanA, leadingSpanB);
            const cloudBottom = Math.min(leadingSpanA, leadingSpanB);
            
            let cloudPosition = 'inside';
            let priceVsCloud = 0;
            
            if (currentPrice > cloudTop) {
                cloudPosition = 'above';
                priceVsCloud = ((currentPrice - cloudTop) / cloudTop) * 100;
            } else if (currentPrice < cloudBottom) {
                cloudPosition = 'below';
                priceVsCloud = ((cloudBottom - currentPrice) / currentPrice) * 100;
            } else {
                cloudPosition = 'inside';
                const cloudThickness = cloudTop - cloudBottom;
                if (cloudThickness > 0) {
                    priceVsCloud = ((currentPrice - cloudBottom) / cloudThickness) * 100;
                }
            }
            
            return {
                cloudPosition: cloudPosition,
                conversionLine: parseFloat(conversionLine.toFixed(2)),
                baseLine: parseFloat(baseLine.toFixed(2)),
                leadingSpanA: parseFloat(leadingSpanA.toFixed(2)),
                leadingSpanB: parseFloat(leadingSpanB.toFixed(2)),
                cloudTop: parseFloat(cloudTop.toFixed(2)),
                cloudBottom: parseFloat(cloudBottom.toFixed(2)),
                priceVsCloud: parseFloat(priceVsCloud.toFixed(2))
            };
        }
        
        // Calculate Exponential Moving Average (EMA)
        function calculateEMA(data, period) {
            if (data.length < period) {
                return new Array(data.length).fill(null);
            }
            
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i];
            }
            
            let emaValue = sum / period;
            ema.push(emaValue);
            
            for (let i = period; i < data.length; i++) {
                emaValue = (data[i] - emaValue) * multiplier + emaValue;
                ema.push(emaValue);
            }
            
            const result = new Array(period - 1).fill(null);
            return result.concat(ema);
        }
        
        // Update the table with current data
        function updateTable() {
            const loadingRow = tableBody.querySelector('.loading');
            if (loadingRow) {
                loadingRow.remove();
            }
            
            const existingRows = tableBody.querySelectorAll('tr[data-symbol]');
            existingRows.forEach(row => row.remove());
            
            let symbolsToDisplay = SYMBOLS;
            if (currentView !== 'all' && watchlists[currentView]) {
                symbolsToDisplay = watchlists[currentView].symbols;
                
                if (symbolsToDisplay.length === 0) {
                    tableBody.innerHTML = `
                        <tr class="loading">
                            <td colspan="24"> <!-- Updated colspan from 25 to 24 -->
                                <div style="padding: 40px; text-align: center;">
                                    <i class="fas fa-star" style="font-size: 2rem; color: #ffc107; margin-bottom: 15px;"></i>
                                    <div>${watchlists[currentView].name} is empty</div>
                                    <div style="margin-top: 10px; font-size: 0.9rem; color: #8a9bb8;">
                                        Click the star icon <i class="far fa-star" style="color: #ffc107;"></i> next to any cryptocurrency to add it to your watchlists.
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                    return;
                }
            }
            
            symbolsToDisplay.forEach(symbol => {
                const data = cryptoData[symbol];
                if (!data) return;
                
                const row = document.createElement('tr');
                row.setAttribute('data-symbol', symbol);
                tableBody.appendChild(row);
                
                const watchlistIds = getWatchlistsForSymbol(symbol);
                const isInAnyWatchlist = watchlistIds.length > 0;
                const starIcon = isInAnyWatchlist ? '<i class="fas fa-star"></i>' : '<i class="far fa-star"></i>';
                const starClass = isInAnyWatchlist ? 'watchlist-star active' : 'watchlist-star';
                
                row.innerHTML = `
                    <td>
                        <div class="crypto-name">
                            <div class="${starClass}" data-symbol="${symbol}">
                                ${starIcon}
                            </div>
                            <div class="crypto-icon ${symbol.substring(0, 3).toLowerCase()}">
                                ${symbol.substring(0, 1)}
                            </div>
                            <div>
                                <div>
                                    <a href="#" class="crypto-link" id="link-${symbol}">
                                        <i class="fas fa-external-link-alt"></i>${symbol}
                                    </a>
                                </div>
                                <div class="price-change" id="change-${symbol}">--</div>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="price" id="price-${symbol}">$${formatNumber(data.currentPrice)}</div>
                    </td>
                    <td>
                        <div class="macd-indicator" id="macd-${symbol}">
                            <span class="macd-badge macd-neutral">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="crossover-indicator" id="crossover-${symbol}">
                            <span class="crossover-badge no-crossover">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="volume-indicator" id="volume-${symbol}">
                            <span class="volume-badge volume-normal">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="atr-indicator" id="atr-${symbol}">
                            <span class="atr-badge atr-low">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="obv-indicator" id="obv-${symbol}">
                            <span class="obv-badge obv-neutral">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="ichimoku-indicator" id="ichimoku-${symbol}">
                            <span class="ichimoku-badge ichimoku-inside">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="ema-indicator" id="ema-${symbol}">
                            <span class="ema-badge ema-cross">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="correlation-indicator" id="correlation-${symbol}">
                            <span class="correlation-badge correlation-low">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="support-levels-indicator" id="support-levels-${symbol}">
                            <span class="support-levels-badge support-levels-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="flipped-support-indicator" id="flipped-support-${symbol}">
                            <span class="flipped-support-badge flipped-support-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="liquidity-grab-support-indicator" id="liquidity-grab-support-${symbol}">
                            <span class="liquidity-grab-support-badge liquidity-grab-support-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="resistance-levels-indicator" id="resistance-levels-${symbol}">
                            <span class="resistance-levels-badge resistance-levels-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="flipped-resistance-indicator" id="flipped-resistance-${symbol}">
                            <span class="flipped-resistance-badge flipped-resistance-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="liquidity-grab-resistance-indicator" id="liquidity-grab-resistance-${symbol}">
                            <span class="liquidity-grab-resistance-badge liquidity-grab-resistance-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="cpr-indicator" id="cpr-${symbol}">
                            <span class="cpr-badge cpr-inside">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="support-convergence-indicator" id="support-convergence-${symbol}">
                            <span class="support-convergence-badge support-convergence-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="resistance-convergence-indicator" id="resistance-convergence-${symbol}">
                            <span class="resistance-convergence-badge resistance-convergence-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="vwap-indicator" id="vwap-${symbol}">
                            <span class="vwap-badge vwap-near">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary1-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">MACD:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary2-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">Volume:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary3-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">CPR-TC:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                    <!-- NEW BINANCE LINK COLUMN -->
                    <td>
                        <div>
                            <a href="#" class="crypto-link binance-link" id="binance-link-${symbol}" style="color: #f0b90b;">
                                <i class="fas fa-exchange-alt"></i>${symbol}
                            </a>
                        </div>
                    </td>
                `;
                
                updatePriceCell(symbol, data.currentPrice, data.priceChange || 0);
                updateMACDCell(symbol, data.macdAnalysis);
                updateCrossoverCell(symbol, data.macdAnalysis);
                updateVolumeCell(symbol, data.volumeSpike);
                updateATRCell(symbol, data.atrAnalysis, data.currentPrice);
                updateOBVCell(symbol, data.obvAnalysis);
                updateIchimokuCell(symbol, data.ichimokuAnalysis, data.currentPrice);
                updateEMACell(symbol, data.emaAnalysis, data.currentPrice);
                updateCorrelationCell(symbol, data.correlationWithBTC || {
                    correlation: 0,
                    percentage: 0,
                    strength: 'unknown',
                    independence: 100,
                    trend: 'unknown'
                });
                updateSupportLevelsCell(symbol, data.supportLevels || [], data.currentPrice);
                updateFlippedSupportCell(symbol, data.flippedLevels || [], data.currentPrice);
                updateLiquidityGrabSupportCell(symbol, data.liquidityGrabSupport || {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Calculating...'
                }, data.currentPrice);
                updateResistanceLevelsCell(symbol, data.resistanceLevels || [], data.currentPrice);
                updateFlippedResistanceCell(symbol, data.flippedResistanceLevels || [], data.currentPrice);
                updateLiquidityGrabResistanceCell(symbol, data.liquidityGrabResistance || {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Calculating...'
                }, data.currentPrice);
                updateCPRCell(symbol, data.cprAnalysis || {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'error',
                    priceVsCPR: 0,
                    range: 0
                }, data.currentPrice);
                updateSupportConvergenceCell(symbol, data.supportConvergence || {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                });
                updateResistanceConvergenceCell(symbol, data.resistanceConvergence || {
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                });
                updateVWAPCell(symbol, data.vwapAnalysis || {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'error',
                    standardDeviation: 0,
                    candlesUsed: 0
                }, data.currentPrice);
                updateIndicatorSummary1Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
                updateIndicatorSummary2Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
                updateIndicatorSummary3Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
                
                // Update star icon
                updateStarIcon(symbol);
            });
        }
        
        // Update price cell with animation
        function updatePriceCell(symbol, price, change) {
            const priceElement = document.getElementById(`price-${symbol}`);
            const changeElement = document.getElementById(`change-${symbol}`);
            
            if (!priceElement) return;
            
            let directionClass = 'neutral';
            let changeText = '';
            
            if (change > 0) {
                directionClass = 'up';
                const prevPrice = price - change;
                changeText = `+${formatNumber(change)} (${prevPrice > 0 ? ((change / prevPrice) * 100).toFixed(2) : '0.00'}%)`;
            } else if (change < 0) {
                directionClass = 'down';
                const prevPrice = price - change;
                changeText = `${formatNumber(change)} (${prevPrice > 0 ? ((change / prevPrice) * 100).toFixed(2) : '0.00'}%)`;
            }
            
            if (changeElement) {
                changeElement.textContent = changeText;
                changeElement.className = `price-change ${directionClass}`;
            }
            
            priceElement.classList.remove('up', 'down', 'neutral');
            priceElement.classList.add(directionClass);
            
            priceElement.style.opacity = '0.7';
            setTimeout(() => {
                priceElement.textContent = `$${formatNumber(price)}`;
                priceElement.style.opacity = '1';
            }, 150);
        }
        
        // Update MACD cell
        function updateMACDCell(symbol, macdData) {
            const macdElement = document.getElementById(`macd-${symbol}`);
            if (!macdElement) return;
            
            let badgeClass = 'macd-neutral';
            let badgeText = 'Analyzing...';
            let detailsHtml = '';
            
            switch (macdData.status) {
                case 'positive':
                    badgeClass = 'macd-positive';
                    badgeText = 'Positive';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                case 'negative':
                    badgeClass = 'macd-negative';
                    badgeText = 'Negative';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                case 'neutral':
                    badgeClass = 'macd-neutral';
                    badgeText = 'Neutral';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'macd-neutral';
                    badgeText = 'Error';
                    detailsHtml = '<div class="macd-details">Error calculating MACD</div>';
            }
            
            macdElement.innerHTML = `
                <span class="macd-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update MACD Crossover cell
        function updateCrossoverCell(symbol, macdData) {
            const crossoverElement = document.getElementById(`crossover-${symbol}`);
            if (!crossoverElement) return;
            
            let badgeClass = 'no-crossover';
            let badgeText = 'None';
            let detailsHtml = '';
            
            switch (macdData.crossover) {
                case 'bullish':
                    badgeClass = 'bullish-crossover';
                    badgeText = 'Bullish Crossover';
                    detailsHtml = `
                        <div class="crossover-details">
                            Recent bullish crossover detected<br>
                            Strength: <span class="percentage">${formatNumber(macdData.crossoverStrength)}</span><br>
                            ${macdData.crossoverPeriodsAgo === 0 ? 'Just occurred' : `${macdData.crossoverPeriodsAgo} period${macdData.crossoverPeriodsAgo > 1 ? 's' : ''} ago`}
                        </div>
                    `;
                    break;
                case 'bearish':
                    badgeClass = 'bearish-crossover';
                    badgeText = 'Bearish Crossover';
                    detailsHtml = `
                        <div class="crossover-details">
                            Recent bearish crossover detected<br>
                            Strength: <span class="percentage">${formatNumber(macdData.crossoverStrength)}</span><br>
                            ${macdData.crossoverPeriodsAgo === 0 ? 'Just occurred' : `${macdData.crossoverPeriodsAgo} period${macdData.crossoverPeriodsAgo > 1 ? 's' : ''} ago`}
                        </div>
                    `;
                    break;
                case 'none':
                    badgeClass = 'no-crossover';
                    badgeText = 'None';
                    detailsHtml = `
                        <div class="crossover-details">
                            No recent crossover detected<br>
                            MACD status: <span class="${macdData.status === 'positive' ? 'percentage' : ''}">${macdData.status}</span>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'no-crossover';
                    badgeText = 'Error';
                    detailsHtml = '<div class="crossover-details">Error detecting crossover</div>';
            }
            
            crossoverElement.innerHTML = `
                <span class="crossover-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Volume Spike cell
        function updateVolumeCell(symbol, volumeData) {
            const volumeElement = document.getElementById(`volume-${symbol}`);
            if (!volumeElement) return;
            
            let badgeClass = 'volume-normal';
            let badgeText = 'Normal';
            let detailsHtml = '';
            
            if (volumeData.spike) {
                badgeClass = 'volume-spike';
                badgeText = `${volumeData.multiple}x Spike`;
                detailsHtml = `
                    <div class="volume-details">
                        Volume: <span class="swing-price">${formatLargeNumber(volumeData.volume)}</span><br>
                        Average (20 candles): <span class="swing-price">${formatLargeNumber(volumeData.averageVolume)}</span><br>
                        <span class="percentage">${volumeData.multiple}x above average</span>
                    </div>
                `;
            } else {
                badgeClass = 'volume-normal';
                badgeText = 'Normal';
                detailsHtml = `
                    <div class="volume-details">
                        Volume: <span class="swing-price">${formatLargeNumber(volumeData.volume)}</span><br>
                        Average (20 candles): <span class="swing-price">${formatLargeNumber(volumeData.averageVolume)}</span><br>
                        ${volumeData.multiple > 0 ? `${volumeData.multiple}x of average` : 'Calculating...'}
                    </div>
                `;
            }
            
            volumeElement.innerHTML = `
                <span class="volume-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update ATR Volatility cell
        function updateATRCell(symbol, atrData, currentPrice) {
            const atrElement = document.getElementById(`atr-${symbol}`);
            if (!atrElement) return;
            
            let badgeClass = 'atr-low';
            let badgeText = 'Low';
            let detailsHtml = '';
            
            switch (atrData.volatility) {
                case 'high':
                    badgeClass = 'atr-high';
                    badgeText = 'High';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Very high volatility</em>
                        </div>
                    `;
                    break;
                case 'moderate':
                    badgeClass = 'atr-moderate';
                    badgeText = 'Moderate';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Higher volatility</em>
                        </div>
                    `;
                    break;
                case 'good':
                    badgeClass = 'atr-good';
                    badgeText = 'Good';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Ideal volatility</em>
                        </div>
                    `;
                    break;
                case 'low':
                    badgeClass = 'atr-low';
                    badgeText = 'Low';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Low volatility</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'atr-low';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="atr-details">Calculating ATR volatility...</div>';
            }
            
            atrElement.innerHTML = `
                <span class="atr-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update OBV cell
        function updateOBVCell(symbol, obvData) {
            const obvElement = document.getElementById(`obv-${symbol}`);
            if (!obvElement) return;
            
            let badgeClass = 'obv-neutral';
            let badgeText = 'None';
            let detailsHtml = '';
            
            switch (obvData.trend) {
                case 'rising':
                    badgeClass = 'obv-rising';
                    badgeText = 'Rising Volume';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">+${obvData.obvChange}%</span><br>
                            Strength: <span class="swing-price">${obvData.trendStrength.toFixed(2)}</span><br>
                            ${obvData.volumeConfirmation ? ' Confirmed with price' : ' No price confirmation'}
                        </div>
                    `;
                    break;
                case 'falling':
                    badgeClass = 'obv-falling';
                    badgeText = 'Declining Volume';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">${obvData.obvChange}%</span><br>
                            Strength: <span class="swing-price">${obvData.trendStrength.toFixed(2)}</span><br>
                            ${obvData.volumeConfirmation ? ' Confirmed with price' : ' No price confirmation'}
                        </div>
                    `;
                    break;
                case 'neutral':
                    badgeClass = 'obv-neutral';
                    badgeText = 'None';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">${obvData.obvChange >= 0 ? '+' : ''}${obvData.obvChange}%</span><br>
                            Volume flow is balanced<br>
                            No clear accumulation or distribution
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'obv-neutral';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="obv-details">Calculating OBV...</div>';
            }
            
            obvElement.innerHTML = `
                <span class="obv-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Ichimoku Cloud cell
        function updateIchimokuCell(symbol, ichimokuData, currentPrice) {
            const ichimokuElement = document.getElementById(`ichimoku-${symbol}`);
            if (!ichimokuElement) return;
            
            let badgeClass = 'ichimoku-inside';
            let badgeText = 'Inside';
            let detailsHtml = '';
            
            switch (ichimokuData.cloudPosition) {
                case 'above':
                    badgeClass = 'ichimoku-above';
                    badgeText = 'Above Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            <span class="percentage">+${ichimokuData.priceVsCloud}% above cloud</span><br>
                            <em>Bullish signal</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'ichimoku-below';
                    badgeText = 'Below Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            <span class="percentage">${ichimokuData.priceVsCloud}% below cloud</span><br>
                            <em>Bearish signal</em>
                        </div>
                    `;
                    break;
                case 'inside':
                    badgeClass = 'ichimoku-inside';
                    badgeText = 'Inside Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            ${ichimokuData.priceVsCloud > 0 ? `<span class="percentage">${ichimokuData.priceVsCloud}% inside cloud</span><br>` : ''}
                            <em>Neutral/Consolidation</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'ichimoku-inside';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="ichimoku-details">Calculating Ichimoku Cloud...</div>';
            }
            
            ichimokuElement.innerHTML = `
                <span class="ichimoku-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update EMA cell
        function updateEMACell(symbol, emaData, currentPrice) {
            const emaElement = document.getElementById(`ema-${symbol}`);
            if (!emaElement) return;
            
            let badgeClass = 'ema-cross';
            let badgeText = 'Near EMA';
            let detailsHtml = '';
            
            switch (emaData.position) {
                case 'above':
                    badgeClass = 'ema-above';
                    badgeText = 'Above EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">+${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Bullish signal</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'ema-below';
                    badgeText = 'Below EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Bearish signal</em>
                        </div>
                    `;
                    break;
                case 'cross':
                    badgeClass = 'ema-cross';
                    badgeText = 'Near EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">${emaData.differencePercentage >= 0 ? '+' : ''}${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Potential crossover zone</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'ema-cross';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="ema-details">Calculating EMA...</div>';
            }
            
            emaElement.innerHTML = `
                <span class="ema-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update correlation with BTC cell
        function updateCorrelationCell(symbol, correlationData) {
            const correlationElement = document.getElementById(`correlation-${symbol}`);
            if (!correlationElement) return;
            
            let badgeClass = 'correlation-low';
            let badgeText = 'Low';
            let detailsHtml = '';
            let progressBarClass = 'low';
            
            switch (correlationData.strength) {
                case 'high':
                    badgeClass = 'correlation-high';
                    badgeText = `High (${correlationData.percentage}%)`;
                    progressBarClass = 'high';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>High correlation with BTC</em>
                        </div>
                    `;
                    break;
                case 'medium':
                    badgeClass = 'correlation-medium';
                    badgeText = `Medium (${correlationData.percentage}%)`;
                    progressBarClass = 'medium';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>Moderate correlation with BTC</em>
                        </div>
                    `;
                    break;
                case 'low':
                    badgeClass = 'correlation-low';
                    badgeText = `Low (${correlationData.percentage}%)`;
                    progressBarClass = 'low';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>Low correlation with BTC (more independent)</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'correlation-low';
                    badgeText = 'Calculating...';
                    detailsHtml = '<div class="correlation-details">Calculating correlation with BTC...</div>';
            }
            
            correlationElement.innerHTML = `
                <span class="correlation-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update support levels cell
        function updateSupportLevelsCell(symbol, supportLevels, currentPrice) {
            const supportElement = document.getElementById(`support-levels-${symbol}`);
            if (!supportElement) return;
            
            let badgeClass = 'support-levels-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (supportLevels && supportLevels.length > 0) {
                badgeClass = 'support-levels-active';
                badgeText = `${supportLevels.length} Support Levels`;
                
                detailsHtml = '<div class="support-levels-details">';
                supportLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item support-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type}</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'support-levels-none';
                badgeText = 'No Support';
                detailsHtml = '<div class="support-levels-details">No support levels detected (LL/HL)</div>';
            }
            
            supportElement.innerHTML = `
                <span class="support-levels-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update flipped support cell
        function updateFlippedSupportCell(symbol, flippedLevels, currentPrice) {
            const flippedElement = document.getElementById(`flipped-support-${symbol}`);
            if (!flippedElement) return;
            
            let badgeClass = 'flipped-support-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (flippedLevels && flippedLevels.length > 0) {
                badgeClass = 'flipped-support-active';
                badgeText = `${flippedLevels.length} Flipped Supports`;
                
                detailsHtml = '<div class="flipped-support-details">';
                flippedLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item flipped-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type} (Breached)</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'flipped-support-none';
                badgeText = 'No Flipped Support';
                detailsHtml = '<div class="flipped-support-details">No flipped support levels detected (Breached HH/LH)</div>';
            }
            
            flippedElement.innerHTML = `
                <span class="flipped-support-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update liquidity grab support cell
        function updateLiquidityGrabSupportCell(symbol, liquidityGrabData, currentPrice) {
            const liquidityElement = document.getElementById(`liquidity-grab-support-${symbol}`);
            if (!liquidityElement) return;
            
            let badgeClass = 'liquidity-grab-support-no';
            let badgeText = 'No';
            let detailsHtml = '';
            
            if (liquidityGrabData.detected && liquidityGrabData.level) {
                badgeClass = 'liquidity-grab-support-yes';
                badgeText = `Yes ($${formatNumber(liquidityGrabData.price)})`;
                
                const percent = formatPercentForLevels(liquidityGrabData.price, currentPrice);
                detailsHtml = `
                    <div class="liquidity-grab-support-details">
                        <strong>Liquidity Grab Detected!</strong><br>
                        Support Level: <span class="swing-price">$${formatNumber(liquidityGrabData.price)}</span><br>
                        Type: <span class="swing-price">${liquidityGrabData.level.type}</span><br>
                        Distance: <span class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                            ${percent.isPositive ? '+' : ''}${percent.value}%
                        </span><br>
                        <em>${liquidityGrabData.details}</em>
                    </div>
                `;
            } else {
                badgeClass = 'liquidity-grab-support-no';
                badgeText = 'No';
                detailsHtml = `
                    <div class="liquidity-grab-support-details">
                        No liquidity grab detected for support levels.<br>
                        <em>Support levels were not breached and reclaimed</em>
                    </div>
                `;
            }
            
            liquidityElement.innerHTML = `
                <span class="liquidity-grab-support-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update resistance levels cell
        function updateResistanceLevelsCell(symbol, resistanceLevels, currentPrice) {
            const resistanceElement = document.getElementById(`resistance-levels-${symbol}`);
            if (!resistanceElement) return;
            
            let badgeClass = 'resistance-levels-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (resistanceLevels && resistanceLevels.length > 0) {
                badgeClass = 'resistance-levels-active';
                badgeText = `${resistanceLevels.length} Resistance Levels`;
                
                detailsHtml = '<div class="resistance-levels-details">';
                resistanceLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item resistance-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type}</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'resistance-levels-none';
                badgeText = 'No Resistance';
                detailsHtml = '<div class="resistance-levels-details">No resistance levels detected (HH/LH)</div>';
            }
            
            resistanceElement.innerHTML = `
                <span class="resistance-levels-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update flipped resistance cell
        function updateFlippedResistanceCell(symbol, flippedResistanceLevels, currentPrice) {
            const flippedElement = document.getElementById(`flipped-resistance-${symbol}`);
            if (!flippedElement) return;
            
            let badgeClass = 'flipped-resistance-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (flippedResistanceLevels && flippedResistanceLevels.length > 0) {
                badgeClass = 'flipped-resistance-active';
                badgeText = `${flippedResistanceLevels.length} Flipped Resistance`;
                
                detailsHtml = '<div class="flipped-resistance-details">';
                flippedResistanceLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item flipped-resistance-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type} (Breached)</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'flipped-resistance-none';
                badgeText = 'No Flipped Resistance';
                detailsHtml = '<div class="flipped-resistance-details">No flipped resistance levels detected (Breached LL/HL)</div>';
            }
            
            flippedElement.innerHTML = `
                <span class="flipped-resistance-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update liquidity grab resistance cell
        function updateLiquidityGrabResistanceCell(symbol, liquidityGrabData, currentPrice) {
            const liquidityElement = document.getElementById(`liquidity-grab-resistance-${symbol}`);
            if (!liquidityElement) return;
            
            let badgeClass = 'liquidity-grab-resistance-no';
            let badgeText = 'No';
            let detailsHtml = '';
            
            if (liquidityGrabData.detected && liquidityGrabData.level) {
                badgeClass = 'liquidity-grab-resistance-yes';
                badgeText = `Yes ($${formatNumber(liquidityGrabData.price)})`;
                
                const percent = formatPercentForLevels(liquidityGrabData.price, currentPrice);
                detailsHtml = `
                    <div class="liquidity-grab-resistance-details">
                        <strong>Liquidity Grab Detected!</strong><br>
                        Resistance Level: <span class="swing-price">$${formatNumber(liquidityGrabData.price)}</span><br>
                        Type: <span class="swing-price">${liquidityGrabData.level.type}</span><br>
                        Distance: <span class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                            ${percent.isPositive ? '+' : ''}${percent.value}%
                        </span><br>
                        <em>${liquidityGrabData.details}</em>
                    </div>
                `;
            } else {
                badgeClass = 'liquidity-grab-resistance-no';
                badgeText = 'No';
                detailsHtml = `
                    <div class="liquidity-grab-resistance-details">
                        No liquidity grab detected for resistance levels.<br>
                        <em>Resistance levels were not breached and reclaimed</em>
                    </div>
                `;
            }
            
            liquidityElement.innerHTML = `
                <span class="liquidity-grab-resistance-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update CPR cell
        function updateCPRCell(symbol, cprData, currentPrice) {
            const cprElement = document.getElementById(`cpr-${symbol}`);
            if (!cprElement) return;
            
            let badgeClass = 'cpr-inside';
            let badgeText = 'Inside CPR';
            let detailsHtml = '';
            
            switch (cprData.position) {
                case 'above':
                    badgeClass = 'cpr-above';
                    badgeText = 'Above CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.cp - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.bc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% above TC)</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'cpr-below';
                    badgeText = 'Below CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.cp - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.bc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% below BC)</em>
                        </div>
                    `;
                    break;
                case 'inside':
                    badgeClass = 'cpr-inside';
                    badgeText = 'Inside CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent ${cprData.cp > currentPrice ? 'percent-negative' : 'percent-positive'}">${cprData.cp > currentPrice ? '-' : '+'}${Math.abs(((cprData.cp - currentPrice) / currentPrice * 100)).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-positive">+${((currentPrice - cprData.bc) / cprData.bc * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% inside CPR range)</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'cpr-inside';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="cpr-details">Calculating Daily CPR using PREVIOUS DAY\'S data...</div>';
            }
            
            cprElement.innerHTML = `
                <span class="cpr-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Support Convergence cell
        function updateSupportConvergenceCell(symbol, convergenceData) {
            const convergenceElement = document.getElementById(`support-convergence-${symbol}`);
            if (!convergenceElement) return;
            
            let badgeClass = 'support-convergence-no';
            let badgeText = 'No Convergence';
            let detailsHtml = '';
            
            if (convergenceData.status === 'Solid Support') {
                badgeClass = 'support-convergence-yes';
                badgeText = 'Solid Support';
                detailsHtml = `
                    <div class="support-convergence-details">
                        <strong>Convergence Found!</strong><br>
                        Convergence Price: <span class="convergence-price">$${formatNumber(convergenceData.price)}</span><br>
                        Support Type: <span class="swing-price">${convergenceData.supportType}</span><br>
                        CPR Level: <span class="swing-price">${convergenceData.cprType}</span><br>
                        Difference: <span class="percentage">${convergenceData.differencePercent}%</span><br>
                        Support Price: <span class="swing-price">$${formatNumber(convergenceData.supportPrice)}</span><br>
                        <em>Strong support zone identified at convergence point</em>
                    </div>
                `;
            } else {
                badgeClass = 'support-convergence-no';
                badgeText = 'No Convergence';
                detailsHtml = `
                    <div class="support-convergence-details">
                        No convergence between support levels and CPR.<br>
                        Support and CPR levels are more than 0.5% apart.<br>
                        <em>Look for levels within 0.5% for stronger support</em>
                    </div>
                `;
            }
            
            convergenceElement.innerHTML = `
                <span class="support-convergence-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // NEW: Update Resistance Convergence cell
        function updateResistanceConvergenceCell(symbol, convergenceData) {
            const convergenceElement = document.getElementById(`resistance-convergence-${symbol}`);
            if (!convergenceElement) return;
            
            let badgeClass = 'resistance-convergence-no';
            let badgeText = 'No Convergence';
            let detailsHtml = '';
            
            if (convergenceData.status === 'Solid Resistance') {
                badgeClass = 'resistance-convergence-yes';
                badgeText = 'Solid Resistance';
                detailsHtml = `
                    <div class="resistance-convergence-details">
                        <strong>Convergence Found!</strong><br>
                        Convergence Price: <span class="convergence-price">$${formatNumber(convergenceData.price)}</span><br>
                        Resistance Type: <span class="swing-price">${convergenceData.resistanceType}</span><br>
                        CPR Level: <span class="swing-price">${convergenceData.cprType}</span><br>
                        Difference: <span class="percentage">${convergenceData.differencePercent}%</span><br>
                        Resistance Price: <span class="swing-price">$${formatNumber(convergenceData.resistancePrice)}</span><br>
                        <em>Strong resistance zone identified at convergence point</em>
                    </div>
                `;
            } else {
                badgeClass = 'resistance-convergence-no';
                badgeText = 'No Convergence';
                detailsHtml = `
                    <div class="resistance-convergence-details">
                        No convergence between resistance levels and CPR.<br>
                        Resistance and CPR levels are more than 0.5% apart.<br>
                        <em>Look for levels within 0.5% for stronger resistance</em>
                    </div>
                `;
            }
            
            convergenceElement.innerHTML = `
                <span class="resistance-convergence-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update VWAP cell with corrected percentage display
        function updateVWAPCell(symbol, vwapData, currentPrice) {
            const vwapElement = document.getElementById(`vwap-${symbol}`);
            if (!vwapElement) return;
            
            let badgeClass = 'vwap-near';
            let badgeText = 'Near VWAP';
            let detailsHtml = '';
            
            // Helper function to format percentage with correct sign
            function formatVWAPPercentage(value) {
                if (value > 0) return `+${value.toFixed(2)}%`;
                if (value < 0) return `${value.toFixed(2)}%`;
                return `0.00%`;
            }
            
            // Get percentage class based on value
            function getPercentageClass(value) {
                if (value > 0) return 'percent-negative'; // Positive = red (overbought)
                if (value < 0) return 'percent-positive'; // Negative = green (oversold)
                return 'percent-positive';
            }
            
            switch (vwapData.position) {
                case 'above':
                    badgeClass = 'vwap-above';
                    badgeText = 'Above VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price is above upper band - statistically overbought</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'vwap-below';
                    badgeText = 'Below VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price is below lower band - statistically oversold</em>
                        </div>
                    `;
                    break;
                case 'near':
                    badgeClass = 'vwap-near';
                    badgeText = 'Near VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price near VWAP line - neutral position</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'vwap-near';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="vwap-details">Calculating VWAP (Session anchor, Source: (H+L+C)/3, Bands: 1 std dev)...</div>';
            }
            
            vwapElement.innerHTML = `
                <span class="vwap-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Indicator Summary 1 cell (MACD, Crossover, Ichimoku, EMA, VWAP Line, VWAP Upper, VWAP Lower)
        function updateIndicatorSummary1Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary1-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // MACD
            let macdColorClass = 'summary-neutral';
            let macdValue = `${summaryData.macd.status}`;
            if (summaryData.macd.status === 'positive') {
                macdColorClass = 'summary-positive';
                macdValue = `Bullish (${formatNumber(summaryData.macd.histogram)})`;
            } else if (summaryData.macd.status === 'negative') {
                macdColorClass = 'summary-negative';
                macdValue = `Bearish (${formatNumber(summaryData.macd.histogram)})`;
            }
            html += `<div class="indicator-summary-item summary-macd ${macdColorClass}">
                <span class="indicator-summary-label">MACD:</span>
                <span class="indicator-summary-value ${macdColorClass}">${macdValue}</span>
            </div>`;
            
            // MACD Crossover
            let crossoverColorClass = 'summary-neutral';
            let crossoverValue = 'None';
            if (summaryData.crossover.type === 'bullish') {
                crossoverColorClass = 'summary-positive';
                crossoverValue = `Bullish (${summaryData.crossover.strength.toFixed(4)})`;
            } else if (summaryData.crossover.type === 'bearish') {
                crossoverColorClass = 'summary-negative';
                crossoverValue = `Bearish (${summaryData.crossover.strength.toFixed(4)})`;
            }
            html += `<div class="indicator-summary-item summary-crossover ${crossoverColorClass}">
                <span class="indicator-summary-label">Crossover:</span>
                <span class="indicator-summary-value ${crossoverColorClass}">${crossoverValue}</span>
            </div>`;
            
            // Ichimoku Cloud
            let ichimokuColorClass = 'summary-neutral';
            let ichimokuValue = `${summaryData.ichimoku.cloudPosition}`;
            if (summaryData.ichimoku.cloudPosition === 'above') {
                ichimokuColorClass = 'summary-positive';
                ichimokuValue = `Above (+${summaryData.ichimoku.priceVsCloud.toFixed(1)}%)`;
            } else if (summaryData.ichimoku.cloudPosition === 'below') {
                ichimokuColorClass = 'summary-negative';
                ichimokuValue = `Below (${summaryData.ichimoku.priceVsCloud.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-ichimoku ${ichimokuColorClass}">
                <span class="indicator-summary-label">Ichimoku:</span>
                <span class="indicator-summary-value ${ichimokuColorClass}">${ichimokuValue}</span>
            </div>`;
            
            // EMA Position
            let emaColorClass = 'summary-neutral';
            let emaValue = `${summaryData.ema.position}`;
            if (summaryData.ema.position === 'above') {
                emaColorClass = 'summary-positive';
                emaValue = `Above (+${summaryData.ema.differencePercentage.toFixed(1)}%)`;
            } else if (summaryData.ema.position === 'below') {
                emaColorClass = 'summary-negative';
                emaValue = `Below (${summaryData.ema.differencePercentage.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-ema ${emaColorClass}">
                <span class="indicator-summary-label">EMA:</span>
                <span class="indicator-summary-value ${emaColorClass}">${emaValue}</span>
            </div>`;
            
            // VWAP Line
            let vwapLineColorClass = 'summary-info';
            let vwapLineValue = `${summaryData.vwap.distanceFromVWAP >= 0 ? '+' : ''}${summaryData.vwap.distanceFromVWAP.toFixed(2)}%`;
            if (summaryData.vwap.position === 'above') {
                vwapLineColorClass = 'summary-negative'; // Above VWAP = overbought (red)
                vwapLineValue = `Above (+${summaryData.vwap.distanceFromVWAP.toFixed(2)}%)`;
            } else if (summaryData.vwap.position === 'below') {
                vwapLineColorClass = 'summary-positive'; // Below VWAP = oversold (green)
                vwapLineValue = `Below (${summaryData.vwap.distanceFromVWAP.toFixed(2)}%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapLineColorClass}">
                <span class="indicator-summary-label">VWAP Line:</span>
                <span class="indicator-summary-value ${vwapLineColorClass}">${vwapLineValue}</span>
            </div>`;
            
            // VWAP Upper Band
            let vwapUpperColorClass = 'summary-info';
            let vwapUpperValue = `${summaryData.vwap.distanceFromUpperBand >= 0 ? '+' : ''}${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%`;
            if (summaryData.vwap.distanceFromUpperBand > 0) {
                vwapUpperColorClass = 'summary-negative'; // Positive = above upper band = overbought
                vwapUpperValue = `Above UB (+${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%)`;
            } else if (summaryData.vwap.distanceFromUpperBand < 0) {
                vwapUpperColorClass = 'summary-positive'; // Negative = below upper band = normal/oversold
                vwapUpperValue = `Below UB (${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%)`;
            } else {
                vwapUpperValue = `At UB (0.00%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapUpperColorClass}">
                <span class="indicator-summary-label">VWAP Upper:</span>
                <span class="indicator-summary-value ${vwapUpperColorClass}">${vwapUpperValue}</span>
            </div>`;
            
            // VWAP Lower Band
            let vwapLowerColorClass = 'summary-info';
            let vwapLowerValue = `${summaryData.vwap.distanceFromLowerBand >= 0 ? '+' : ''}${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%`;
            if (summaryData.vwap.distanceFromLowerBand > 0) {
                vwapLowerColorClass = 'summary-negative'; // Positive = above lower band = normal/overbought
                vwapLowerValue = `Above LB (+${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%)`;
            } else if (summaryData.vwap.distanceFromLowerBand < 0) {
                vwapLowerColorClass = 'summary-positive'; // Negative = below lower band = oversold
                vwapLowerValue = `Below LB (${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%)`;
            } else {
                vwapLowerValue = `At LB (0.00%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapLowerColorClass}">
                <span class="indicator-summary-label">VWAP Lower:</span>
                <span class="indicator-summary-value ${vwapLowerColorClass}">${vwapLowerValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Update Indicator Summary 2 cell (Volume, OBV, Support, Flipped Support, Liquidity Grab Support, Resistance, Flipped Res, Liquidity Grab Resistance)
        function updateIndicatorSummary2Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary2-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // Volume Spike
            let volumeColorClass = summaryData.volumeSpike.spike ? 'summary-info' : 'summary-neutral';
            let volumeValue = summaryData.volumeSpike.spike ? `${summaryData.volumeSpike.multiple}x Spike` : 'Normal';
            html += `<div class="indicator-summary-item summary-volume ${volumeColorClass}">
                <span class="indicator-summary-label">Volume:</span>
                <span class="indicator-summary-value ${volumeColorClass}">${volumeValue}</span>
            </div>`;
            
            // OBV
            let obvColorClass = 'summary-neutral';
            let obvValue = `${summaryData.obv.trend}`;
            if (summaryData.obv.trend === 'rising') {
                obvColorClass = 'summary-positive';
                obvValue = `Rising (+${summaryData.obv.obvChange.toFixed(1)}%)`;
            } else if (summaryData.obv.trend === 'falling') {
                obvColorClass = 'summary-negative';
                obvValue = `Falling (${summaryData.obv.obvChange.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-obv ${obvColorClass}">
                <span class="indicator-summary-label">OBV:</span>
                <span class="indicator-summary-value ${obvColorClass}">${obvValue}</span>
            </div>`;
            
            // Support Levels (Percentage only)
            let supportColorClass = 'summary-neutral';
            let supportValue = 'None';
            if (summaryData.supportLevels.hasLevels) {
                supportColorClass = summaryData.supportLevels.percentage >= 0 ? 'summary-positive' : 'summary-negative';
                supportValue = `${summaryData.supportLevels.percentage >= 0 ? '+' : ''}${summaryData.supportLevels.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-support ${supportColorClass}">
                <span class="indicator-summary-label">Support:</span>
                <span class="indicator-summary-value ${supportColorClass}">${supportValue}</span>
            </div>`;
            
            // Flipped Support (Percentage only)
            let flippedColorClass = 'summary-neutral';
            let flippedValue = 'None';
            if (summaryData.flippedSupport.hasLevels) {
                flippedColorClass = summaryData.flippedSupport.percentage >= 0 ? 'summary-positive' : 'summary-negative';
                flippedValue = `${summaryData.flippedSupport.percentage >= 0 ? '+' : ''}${summaryData.flippedSupport.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-flipped ${flippedColorClass}">
                <span class="indicator-summary-label">Flipped S:</span>
                <span class="indicator-summary-value ${flippedColorClass}">${flippedValue}</span>
            </div>`;
            
            // Liquidity Grab Support
            let liquiditySupportColorClass = 'summary-neutral';
            let liquiditySupportValue = 'No';
            if (summaryData.liquidityGrabSupport.detected) {
                liquiditySupportColorClass = 'summary-positive';
                liquiditySupportValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-liquidity-support ${liquiditySupportColorClass}">
                <span class="indicator-summary-label">Liquidity S:</span>
                <span class="indicator-summary-value ${liquiditySupportColorClass}">${liquiditySupportValue}</span>
            </div>`;
            
            // Resistance Levels (Percentage only)
            let resistanceColorClass = 'summary-neutral';
            let resistanceValue = 'None';
            if (summaryData.resistanceLevels.hasLevels) {
                resistanceColorClass = summaryData.resistanceLevels.percentage >= 0 ? 'summary-negative' : 'summary-positive';
                resistanceValue = `${summaryData.resistanceLevels.percentage >= 0 ? '+' : ''}${summaryData.resistanceLevels.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-resistance ${resistanceColorClass}">
                <span class="indicator-summary-label">Resistance:</span>
                <span class="indicator-summary-value ${resistanceColorClass}">${resistanceValue}</span>
            </div>`;
            
            // Flipped Resistance (Percentage only)
            let flippedResistanceColorClass = 'summary-neutral';
            let flippedResistanceValue = 'None';
            if (summaryData.flippedResistance.hasLevels) {
                flippedResistanceColorClass = summaryData.flippedResistance.percentage >= 0 ? 'summary-negative' : 'summary-positive';
                flippedResistanceValue = `${summaryData.flippedResistance.percentage >= 0 ? '+' : ''}${summaryData.flippedResistance.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-flipped-resistance ${flippedResistanceColorClass}">
                <span class="indicator-summary-label">Flipped R:</span>
                <span class="indicator-summary-value ${flippedResistanceColorClass}">${flippedResistanceValue}</span>
            </div>`;
            
            // Liquidity Grab Resistance
            let liquidityResistanceColorClass = 'summary-neutral';
            let liquidityResistanceValue = 'No';
            if (summaryData.liquidityGrabResistance.detected) {
                liquidityResistanceColorClass = 'summary-negative';
                liquidityResistanceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-liquidity-resistance ${liquidityResistanceColorClass}">
                <span class="indicator-summary-label">Liquidity R:</span>
                <span class="indicator-summary-value ${liquidityResistanceColorClass}">${liquidityResistanceValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Update Indicator Summary 3 cell (CPR-TC, CPR-CP, CPR-BC, Correlation with BTC, Support Convergence with CPR, Resistance Convergence with CPR, ATR)
        function updateIndicatorSummary3Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary3-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // CPR-TC
            let cprTcColorClass = 'summary-info';
            let cprTcValue = `${summaryData.cpr.tcPercentage >= 0 ? '+' : ''}${summaryData.cpr.tcPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprTcColorClass}">
                <span class="indicator-summary-label">CPR-TC:</span>
                <span class="indicator-summary-value ${cprTcColorClass}">${cprTcValue}</span>
            </div>`;
            
            // CPR-CP
            let cprCpColorClass = 'summary-info';
            let cprCpValue = `${summaryData.cpr.cpPercentage >= 0 ? '+' : ''}${summaryData.cpr.cpPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprCpColorClass}">
                <span class="indicator-summary-label">CPR-CP:</span>
                <span class="indicator-summary-value ${cprCpColorClass}">${cprCpValue}</span>
            </div>`;
            
            // CPR-BC
            let cprBcColorClass = 'summary-info';
            let cprBcValue = `${summaryData.cpr.bcPercentage >= 0 ? '+' : ''}${summaryData.cpr.bcPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprBcColorClass}">
                <span class="indicator-summary-label">CPR-BC:</span>
                <span class="indicator-summary-value ${cprBcColorClass}">${cprBcValue}</span>
            </div>`;
            
            // Correlation with BTC
            let correlationColorClass = 'summary-neutral';
            let correlationValue = `${summaryData.correlation.percentage.toFixed(1)}%`;
            if (summaryData.correlation.strength === 'low') {
                correlationColorClass = 'summary-positive'; // Low correlation = more independent (green)
                correlationValue = `Low (${summaryData.correlation.percentage.toFixed(1)}%)`;
            } else if (summaryData.correlation.strength === 'medium') {
                correlationColorClass = 'summary-neutral'; // Medium correlation = neutral (yellow)
                correlationValue = `Medium (${summaryData.correlation.percentage.toFixed(1)}%)`;
            } else if (summaryData.correlation.strength === 'high') {
                correlationColorClass = 'summary-negative'; // High correlation = follows BTC (red)
                correlationValue = `High (${summaryData.correlation.percentage.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-correlation ${correlationColorClass}">
                <span class="indicator-summary-label">Correlation:</span>
                <span class="indicator-summary-value ${correlationColorClass}">${correlationValue}</span>
            </div>`;
            
            // Support Convergence with CPR
            let supportConvergenceColorClass = 'summary-neutral';
            let supportConvergenceValue = 'No';
            if (summaryData.supportConvergence.status === 'Solid Support') {
                supportConvergenceColorClass = 'summary-positive';
                supportConvergenceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-convergence ${supportConvergenceColorClass}">
                <span class="indicator-summary-label">Conv. S-CPR:</span>
                <span class="indicator-summary-value ${supportConvergenceColorClass}">${supportConvergenceValue}</span>
            </div>`;
            
            // NEW: Resistance Convergence with CPR
            let resistanceConvergenceColorClass = 'summary-neutral';
            let resistanceConvergenceValue = 'No';
            if (summaryData.resistanceConvergence.status === 'Solid Resistance') {
                resistanceConvergenceColorClass = 'summary-negative';
                resistanceConvergenceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-resistance-convergence ${resistanceConvergenceColorClass}">
                <span class="indicator-summary-label">Conv. R-CPR:</span>
                <span class="indicator-summary-value ${resistanceConvergenceColorClass}">${resistanceConvergenceValue}</span>
            </div>`;
            
            // ATR
            let atrColorClass = 'summary-neutral';
            let atrValue = `${summaryData.atr.volatility} (${summaryData.atr.atrPercentage}%)`;
            if (summaryData.atr.volatility === 'high') {
                atrColorClass = 'summary-negative'; // High volatility = risky (red)
            } else if (summaryData.atr.volatility === 'moderate') {
                atrColorClass = 'summary-neutral'; // Moderate volatility = neutral (yellow)
            } else if (summaryData.atr.volatility === 'good') {
                atrColorClass = 'summary-positive'; // Good volatility = ideal (green)
            } else if (summaryData.atr.volatility === 'low') {
                atrColorClass = 'summary-neutral'; // Low volatility = neutral (yellow)
            }
            html += `<div class="indicator-summary-item summary-atr ${atrColorClass}">
                <span class="indicator-summary-label">ATR:</span>
                <span class="indicator-summary-value ${atrColorClass}">${atrValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Format numbers with commas (for prices)
        function formatNumber(num) {
            if (num === 0 || !num) return '0.00';
            
            if (Math.abs(num) < 0.01) {
                return num.toFixed(6);
            }
            
            if (Math.abs(num) < 1000) {
                return num.toFixed(4);
            }
            
            return num.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // Format large numbers (for volumes and OBV)
        function formatLargeNumber(num) {
            if (num === 0 || !num) return '0';
            
            if (Math.abs(num) >= 1000000000) {
                return (num / 1000000000).toFixed(2) + 'B';
            } else if (Math.abs(num) >= 1000000) {
                return (num / 1000000).toFixed(2) + 'M';
            } else if (Math.abs(num) >= 1000) {
                return (num / 1000).toFixed(2) + 'K';
            } else {
                return num.toFixed(2);
            }
        }
        
        // Show error message
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
        }
        
        // Clear error message
        function clearError() {
            errorMessage.classList.remove('show');
        }
    </script>
</body>
</html>